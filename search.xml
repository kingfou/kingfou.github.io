<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[java面试题之4java缓存机制]]></title>
      <url>%2F2017%2F05%2F05%2F%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[缓存是什么缓存就是将频繁使用到的数据先存在内存或者硬盘里面，需要的时候可以直接在内存里面提取，内存的速度是很快的，可以提高效率。 JAVA里面实现我们的常见缓存在java里面，我们缓存的实现，其实就是实现一个静态的HashMap，之后实现数据的增删改查就可以。对于缓存数据，我们设置好数据缓存的时间，当时间到了就清除该缓存。这个只需要执行一个线程就可以实现。实现我们的HashMap的数据缓存： 设计我们的缓存单元类：存活时间，建立时间，数据内容（数据是对象，Object）; 设计我们的缓存管理接口：接口里面有缓存管理的所有方法： 增加put(String key,EnCache cache); 增加put(String key,Object obj,Long lastTime); 删除 是否存在该键值 获得静态Map; 获得所有的key进行遍历3.实现一个线程对我们的缓存管理类进行监听，当缓存时间到的时候，自动清除Map里面的数据。线程的作用就是遍历静态HashMap里面的数据，查看istimeOut是否超时。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java面试题之3]]></title>
      <url>%2F2017%2F05%2F05%2F%E9%9D%A2%E8%AF%95%E9%A2%983%2F</url>
      <content type="text"><![CDATA[MySQL数据库性能调优什么是索引？索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。如果表有1000个记录，通过索引查找记录至少要比顺序扫描记录快100倍。简单的说，索引就是先将对数据的执行分类，好比一个字典，前面的那些拼音，偏旁部首，几笔几划什么的都是索引，他会先把每个记录的指向按照索引先得到一站表，从左向右不断的缩小范围，最后找到我们需要的数据，索引的建立其实就是在表建立的时候对数据做了进一步的优化。 索引的类型根据从左到右这个索引查找规则，建立我们的索引，索引最好是int数据类，而且数据类型的大小最小越好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java面试题之2]]></title>
      <url>%2F2017%2F05%2F05%2FJAVA%E9%9D%A2%E8%AF%95%E9%A2%982%2F</url>
      <content type="text"><![CDATA[线程深入 线程和进程的区别： 进程是什么？进程是程序执行的一个实例。每一个进程都有自己的独立的一块内存空间、一组资源系统。其内部数据和状态都是完全独立的。系统的引导的时候会开启很多服务，这些服务就叫做守护进程，也叫后台服务程序，它的生命周期较长，在系统关闭时终止。 线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。 线程的状态： 创建状态：就是Thread t=new Thread(Runnable tagret);表示创建一个线程 就绪状态：t1.start()表示线程准备就绪，随时抢占cpu资源，注意一点，调用start（）方法并不是立刻就开始执行，这个是要看cpu调度的。 运行状态：Thread里面的run()方法正在运行二等状态，也就是线程的业务开始执行 阻塞状态:在多线程中，每个线程得到cpu使用权基本一样，每个线程都要抢占cpu，当一个线程没有被cpu调度的时候，它就会处于阻塞状态，等待cpu的调度。 终止状态：线程执行完毕或者调用了stop()方法使得现场终止。 Thread线程实现的两种方法： 继承Thread类并覆写run()方法，实例化对象后就可以调用。 实现Runnable接口，覆写run()方法，实例化对象的形式是Thread t1=new Thread(Runnable taget)target是实现了Runnable接口的子类实例。 使用Thread继承和runnable实现的线程的区别：使用Thread类的时候，无法实现资源的共享，使用Runnable的时候能实现资源共享。也就是说，多个线程共同操作一个资源。但是，这样不能保证线程之间的同步，也就是说，可能这个线程在操作这个资源的时候，另外一个线程也在操作这个资源。怎么说，一个线程在执行的时候，这个线程本身可能有很多的操作步骤，但是由于线程的执行机制，这个线程在执行的时候，可能只执行了几步就被叫停，其他线程接手执行。这样就会造成资源的具体情况在各个线程之间有延迟。所以需要进行代码块的同步，使得这个代码块是一次全部完成的，也就是一个线程得到cup调度的时候，它可以执行完全部代码，之后再交出使用权。在买票的系统里面，只有一个线程可以将所有的票卖完。这是我们自己的代码的问题。 一个对象有一个锁，当一个线程访问一个对象的同步方法或者同步代码块的时候，它就会获得这个对象的锁，其他线程如果在同时间也想访问的话，就得等待那个线程执行完同步代码块后释放该对象锁。如果是不同对象的话，那么他们之间其实不存在锁的竞争关系的。则他们的输出其实和没有同步的输去规则是一样的，但是这时候的数据是安全的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 public class MyDemon2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Info info=new Info();//同一个对象 Info info1=new Info();//同一个对象 new MyThread(info).start(); new MyThread(info).start(); new MyThread(info1).start(); new MyThread(info1).start(); &#125;&#125;class Info&#123; private int money=5; private int ticket=6; public synchronized void show1()&#123; System.out.println(Thread.currentThread().getName()+&quot;获取对象锁&quot;); for(int x=0;x&lt;10;x++)&#123; if(money&gt;0)&#123; System.out.println(&quot;money的值为&quot;+money--); &#125; &#125; money=5; &#125; public synchronized void show2()&#123; System.out.println(Thread.currentThread().getName()+&quot;获取对象锁&quot;); for(int x=0;x&lt;10;x++)&#123; if(ticket&gt;0)&#123; System.out.println(&quot;money的值为&quot;+ticket--); &#125; &#125; &#125; &#125;class MyThread extends Thread&#123; private Info info=null; public MyThread(Info info)&#123; this.info=info; &#125; @Override public void run() &#123; // TODO Auto-generated method stub info.show1(); &#125; &#125; 由输出结果可以知道，线程0和线程1是竞争关系，线程2和3是竞争关系，所有0和1,2和3是一部打印内容的，但是0和2,3还有1和2,3是没有关系的，他们之间就是没有同步的时候的输出情况了，但是此时他们是没有竞争关系的，更谈不上对数据的破坏。 类锁。当同步静态方法的时候，我们使用的是类锁，一个类的静态变量和方法是所有对象共享的，也就是和对象无关。所以即使是不同的对象访问同步的静态方法，他们之间的关系也是竞争关系。 进一步了解线程：多个对象多个线程之间的关系。多个线程访问同一个对象的同步代码块的时候，锁是由竞争关系的，所以是那个线程先获得对象锁先访问，当竞争的线程越多的时候，随机性越明显。总之就是同一个对象的时候，是竞争关系，这时候的输出是看那个线程先得到对象的锁的。在测试的代码里面，如果我们的线程比较少的时候，它的访问顺序似乎和代码的顺序是有关的，其实没有关系的。你将竞争的线程多开几个就可以知道是随机的。 使用Lock接口实现代码块的同步，在这里我们知道，存在竞争对象的线程，其实只在同步代码块那一部分有锁的竞争，其他地方是不存在的。也就是synchronized（）{}前后的代码是不同步的。即使是在run方法里面。 通过消费者和生产者模式进行深度了解：class Info { 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 private String nameString; private String content; private boolean flag=false;//线程工作标志位,每个线程都在改变这个标志位 //生产消息： public synchronized void setMsg(String name,String cont)&#123; if(flag)&#123; try &#123; System.out.println(&quot;生产的线程&quot;+Thread.currentThread().getName()+&quot;等待，有产品存在！&quot;); super.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;开始生产&quot;); this.nameString=name; this.content=cont; flag=true; super.notify(); &#125; public synchronized void getMsg()&#123; if(!flag)&#123; try &#123; System.out.println(&quot;消费的线程&quot;+Thread.currentThread().getName()+&quot;等待，没有产品存在！&quot;); super.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;消费：&quot;+nameString+&quot;--&gt;&quot;+content); flag=false; super.notify(); &#125;&#125;class Product implements Runnable&#123; private Info info; boolean flag=false; public Product(Info info)&#123; this.info=info; &#125; @Override public void run() &#123;//生产者一次生成两个产品。 // TODO Auto-generated method stub for(int i=0;i&lt;20;i++)&#123; if(flag)&#123; info.setMsg(&quot;产品1&quot;, &quot;食品&quot;); flag=false; &#125;else&#123; info.setMsg(&quot;产品2&quot;, &quot;日用品&quot;); flag=true; &#125; &#125; &#125; &#125;class Customer implements Runnable&#123; private Info info=null; public Customer(Info info) &#123; // TODO Auto-generated constructor stub this.info=info; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for(int i=0;i&lt;20;i++)&#123; info.getMsg(); &#125; &#125;&#125;public class TestDemon &#123; public static void main(String[] args) &#123; Info info=new Info();//同一个对象 Product pro=new Product(info); Customer cus=new Customer(info); new Thread(pro).start(); new Thread(cus).start(); &#125;&#125; 从上面的例子我们可以知道，其实这个就是对线程的认为调度，也就是使得线程一次执行，轮流执行。那么是怎么办到的呢？其实很简单，那就是使用wait()和notify()对线程进行唤醒和等待（线程阻塞），之后就是线程的唤醒。如果只有两个线程，那么就是唤醒就行，而不是唤醒所有。一个线程执行完后就唤醒其他线程，这样每次只有一个线程在执行。之一wiat（）方法后面的语句是在线程被唤醒后执行的。在同步的代码块里面，线程如果被wiat()的话，那么这个线程是暂停在此处，当被唤醒的时候，会继续执行下去。消费者和生产者的产品对象是同一个对象，两个线程之间是存在竞争关系的。但是，一个线程获得一个对象锁的时候（其实就是得到执行synchronized代码块的去权利），它在执行的时候，我们让他进行判断，使得它存在 执行 或者 wait()阻塞状态。每次执行完一个同步代码块后，两个线程都会再次进行竞争。 理解run（）在线程里的执行。当我们对一个线程启动start（）的时候，其实就是运行我们的run()方法体里面的代码，里面的代码在线程的执行的时候，是竞争关系的，虽然大家最后都完成任务，但是过程确是随机的。我们的run（）里面如果出现sychronized代码块，那么只是这个代码块里面的内容是同步的，其他的代码还是继续抢占资源的存在。同步代码块的执行就是给获得执行机会的线程执行完这个代码块的权利，此时其他线程是无法操作这些代码的。同时也无法操作该对象里面的其他sychronized代码，也就是说只有一个线程可以操作所有的sychronized代码，但是对于没有同步的代码，线程是可以同时操作的。理解我们的生产者和消费者模式的设计：线程同时进入两个run里面，执行代码，但是由于是对象同步的，如果没有进行线程的控制的话（wait()和notify()操作）只是单纯的执行sychronized的话，由于同一个线程可以多次获得一个对象的锁，所有会存在消费者消费完该产品的时候，会再次消费该产品，因为此时消费的线程再次获得锁访问资源，但是该资源还没有更新。（一般是消费者消费后，该线程要进入wait()模式等待数据更新，如果该线程再次获得锁进入来，那么由于标志位的反转，它就得处于wait()阻塞状态）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java面试题之3]]></title>
      <url>%2F2017%2F05%2F05%2FJAVA%E9%9D%A2%E8%AF%95%E9%A2%983%2F</url>
      <content type="text"><![CDATA[常量和静态变量的区别1、非基本类型的常量一但赋值后,不能修改其引用，但可以改变引用所指对象的属性值：eg: class A { int a ;//类A的一个属性 } final A a = new A();//定义一个非基本类型的常量 a a.a=7; 这是可以的 a.a=8:这是可以的 但是a= new A();这是不可以的（试图重新给a引用一个新的对象（错）） 2、基本类型常量是不能修改其值。 3、静态变量本质是变量 是整个类所有对象所共享的一个变量，其值一但改变对这个类的所有对象都有影响。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jsp页面使用的EL表达式和JSTL标签库]]></title>
      <url>%2F2017%2F05%2F03%2FJSP%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%2F</url>
      <content type="text"><![CDATA[认识EL和JSTL这两者的使用其实是为了减少在jsp页面编写java代码，使得web应用的视图层和控制层耦合进一步降低。使用我们得el表达式可以很简单的获取到jsp内置对象里面的数据，结合我们的JSTL表达式，我们可以进行一些更加复杂的操作，例如，JSTL标签库里面的核心标签库就提供了很多的方法&lt;,有循环，判断，表格，什么的支持。这样可以使得我们的数据获取和业务逻辑更加简洁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java面试题之一]]></title>
      <url>%2F2017%2F05%2F03%2FJava%E9%9D%A2%E8%AF%95%E9%A2%981%2F</url>
      <content type="text"><![CDATA[为什么要使用接口？ 由于java里面类的继承是单继承，为了实现多基础，我们使用了接口 接口就是标准，是用来隔离具体实现的（或者说是和具体实现解耦） 达到统一访问的目的，因为你实现这个接口的类的方法名相同，但是实现内容不同我用接口来定义对象不就可以做到统一访问。所谓的统一的访问标准其实就是对象不用变，但是访问的权限改变（这个是多态性实现的。） 抽象类和接口的区别： 声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。 this和super的区别:在Java中，this通常指当前对象，super则指父类的。 1.this表示指向当前对象的指针，同时也可以调用当前对象的其他构造函数。 2.super表示指向父类的指针，使用它可以得到父类的属性或者方法。同时，子类的构造函数必须实现父类的构造函数，使用的就是super()或者super(param). Object类里面定义的线程的方法： 1.wait()是一个线程处于等待的状态，并且释放所持有的对象的lock(持有lock的对象才可以对资源进行访问！) 2.sleep()是一个线程进行休眠，时间一到继续运行，这个和wait（）是不同的。 3.notify():唤醒一个正在等待的线程，注意是在调用此方法的时候，并不能确切的唤醒某一个线程，这个是有JVM决定的。 JAVA实现多态的机制是什么？是子类中方法的覆写以及同一个类里面方法的重载。多态有两种，一种是运行时多态，一种是编译时多态。一般来说，运行时多态指的就是重载，因为这时候的方法名称和参数全部一样，所以要使用到绑定技术，，而编译时多态其实就是在编译的时候就可以确定调用哪个方法了。JAVA内存详解首先，java将对内存的管理直接交给了jvm，也就是它会自动的帮我们进行GC(垃圾回收)而不用我们程序员自己手动的进行GC(c++就要。)但是有时候如果内存溢出出现错误的话，我们还是要自己进行手动的处理。所以理解java内存操所是很有必要的。首先，了解什么是JVM,JVM是java虚拟机，为什么java可以实现平台无关？其实JVM扮演的就是一个java程序和操作系统的桥梁，也就说，所有的工作由JVM进行，内存的调度也是JVM完成的。 栈：保存局部变量的值。这里的局部变量有：1.基本数据类的值 2.保存类的实例（这个类的实例，其实就是对象的引用，Object obj=new Object(),这时候的obj是对象实例，new Object是对象。obj知识一个指向对堆内存的指针） 堆：用来存动态产生的数据，比如书new出来的新对象（注意区分什么是实例，什么是对象！！new出来的是对象。）注意，此时创建出来的对象只包含了属于各自成员变量，并不包括成员方法，因为同一个类的对象拥有各自的成员变量，存储在各自的堆内存，但是他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次。 常量池：JVM为每个已经加载的类型维护一个常量池。包括（基本数据类型，String）和对其他类型，方法，字段的符号引用。其实变量类型，就两种类型的变量：基本类型和引用类型。二者作为局部变量，都放在栈中，基本类型直接在栈中保存值，引用类型只保存一个指向堆区的指针，真正的对象在堆里。作为参数时基本类型就直接传值，引用类型传指针。1.分清什么是实例什么是对象。Class a= new Class();此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。 2.栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。3.常量池维护的问题： public class TestConstant { public static void main(String[] args) { Integer a=40; Integer b=40; System.out.println(a==b); Integer c=400; Integer d=400; System.out.println(c==d); } } 第一个输出是true，第二个是false;为什么？常量池维护的常量为-127-127，当你的数据超过127时，是要使用new Integer()创建出一个新的对象的。这当然就不一样了，40之所以一样是因为常量池里面维护着-127-127这范围里面的对象了。这个其实是一个装箱技术实现的，它会判断被装箱的数据是不是在-127-127之间。堆里面-127-127对象只有一个对象，其他实例直接指向它们就可以。2.String类型也实现了常量池技术，但是稍微有点不同。String型是先检测常量池中有没有对应字符串，如果有，则取出来；如果没有，则把当前的添加进去。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java泛型]]></title>
      <url>%2F2017%2F05%2F03%2F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1md%2F</url>
      <content type="text"><![CDATA[认识泛型泛型可以解决数据类型转换之中的安全问题，它的主要原理就是，在类的声明的时候，通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这样在类声明或者实例化的时候只要指定好需要的类型即可。在类型转换的例子中，我们由过自动拆箱和自动装箱的机制，只需要将我们的类声明为Object即可。型的定义：泛型是JDK 1.5的一项新特性，它的本质是参数化类型（Parameterized Type）的应用，也就是说所操作的数据类型被指定为一个参数，在用到的时候在指定具体的类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。 泛型思想早在C++语言的模板（Templates）中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。例如在哈希表的存取中，JDK 1.5之前使用HashMap的get()方法，返回值就是一个Object对象，由于Java语言里面所有的类型都继承于java.lang.Object，那Object转型为任何对象成都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会被转嫁到程序运行期之中。 泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符）或是运行期的CLR中都是切实存在的，List与List就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型被称为真实泛型。 Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经被替换为原来的原始类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList与ArrayList就是同一个类。所以说泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为伪泛型。（类型擦除在后面在学习） 使用泛型机制编写的程序代码要比那些杂乱的使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。泛型对于集合类来说尤其有用。 泛型程序设计（Generic Programming）意味着编写的代码可以被很多不同类型的对象所重用。 泛型的构造泛型的使用需要遵循的规律如下： 泛型类的使用：一个泛型类（generic class）就是具有一个或多个类型变量的类。定义一个泛型类十分简单，只需要在类名后面加上&lt;&gt;，再在里面加上类型参数： class Pair { private T value; public Pair(T value) { this.value=value; } public T getValue() { return value; } public void setValue(T value) { this.value = value; } } 泛型接口的定义和使用定义泛型接口和泛型类差不多，看下面简单的例子： interface Show&lt;T,U&gt;{ void show(T t,U u); } class ShowTest implements Show&lt;String,Date&gt;{ @Override public void show(String str,Date date) { System.out.println(str); System.out.println(date); } } 泛型方法的定义和使用泛型类在多个方法签名间实施类型约束。在 List 中，类型参数 V 出现在 get()、add()、contains() 等方法的签名中。当创建一个 Map 类型的变量时，您就在方法之间宣称一个类型约束。您传递给 add() 的值将与 get() 返回的值的类型相同。类似地，之所以声明泛型方法，一般是因为您想要在该方法的多个参数之间宣称一个类型约束。举个简单的例子： public static void main(String[] args) throws ClassNotFoundException { String str=get(&quot;Hello&quot;, &quot;World&quot;); System.out.println(str); } public static &lt;T, UT get(T t, U u) { if (u != null) return t; else return null; } 总结泛型的使用是写了一个标识这样就是表示我们使用了泛型。在类和接口的声明里面是 class name&lt;T1,T2,T3....&gt;{}在接口里面是 `Interface name&lt;T1,T2,T3...&gt;{}` 在方法里面是 &lt;T1,T2,T3&gt; T1 name(T2 param1,T2 param2){}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jsp九大内置对象]]></title>
      <url>%2F2017%2F05%2F03%2Fjsp%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[内置对象所谓的内置对象其实就是在jsp页面生成的时候，就自己已经声明和实例化好了的，我们可以直接使用到的对象了。 九大内置对象介绍 request:request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。也就是每次的request的内容其实是不一样的。 response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。一个页面只会响应最后一个内容输出。 session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。 application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。 out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。 page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。 exception 对象的作用是显示异常信息，只有在包含 isErrorPage=”true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。 config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。 pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F05%2F03%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[什么是正则表达式正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 注意事项 []表示匹配的字符范围，也就是需要匹配的字符都在里面，例如[a-z]表示a-z之间的任意字母都可以{}表示匹配的字符数，也就是要匹配几个字符，例如：[abcdefg]{3}表示在adcdefg这所有的字符里面的三个拿出来匹配，&quot;ac.matchers(&quot;[abcdefg]{3}&quot;)&quot;返回的是false，因为2个和三个无法匹配！ 范围的扩大。我们知道[]表示的是匹配的范围，也就是需要的字符得放在[]里面，我们可以对一些[]进行扩充，[[a-z][A-Z]]就表示由两个字符范围组合成的一个更大的字符fanwei[a-zA-Z];这个在邮箱的正则表达式里面会用到。 a,a?,a+分别表示字符a存在的数量，表示0或者多个，？表示一个或者没有，+表示一个或者多个。 反斜杠的存在；由于一些特殊的字符，我们需要使用反斜杠进行表示，例如，我们需要一个反斜杠，那么写法就是”\“,我们需要一个dot，那么就是”\.”,”\w”表示的是[a-zA-Z0-9]也就是所有的数字和字母的组合。就是注意由于双引号的存在，我们的表达式的写法要注意。 对我们的正则表达式进行编译：Pattern pattern=Pattern.compile(&quot;[\\w[.-]]+@[\\w[.-]]+\\.[\\w]+&quot;);这样可以提到我们的效率。同时，使用我们的类进行匹配，可以进行更多的数据操作，而不仅仅是返回时候匹配这个最简单的问题。Matcher matcher=pattern.matcher(checkmainString);这句话是对需要进行匹配的字符串checkmainString进行匹配。匹配的结果放到我们的matcher对象里。matcher对象可以进行很多的操作。使用find()函数可以得到匹配的数据的下一个光标，相当于我们的hasNext(),使用group()函数可以得到find里的数据，相当于我们的next()函数得到数据内容。使用matcher对象我们可以完成更多的操作。 网页数据爬取，其实就是使用正则表达式爬取我们需要的数据的一个过程，一般的爬虫是使用python写的。 一个简单的邮箱爬取程序如下： import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegExpression { public static void main(String[] args) { // TODO Auto-generated method stub String checkmainString=&quot;ansdnasdjna&quot; + &quot; 39177@qq.com askcscn 1e233223 &quot; + &quot;qweqweqwiwn dkaks ^%$#^* )(&amp;&amp;&amp;T &quot; + &quot;&amp;%^DGusnoc*H 7878@163.com asican&quot; + &quot;67681w8ac giam@gmain.cn casdnasohsa&quot; + &quot;hdajsdneind jinfu@scnu.edu&quot;; Pattern pattern=Pattern.compile(&quot;[\\w[.-]]+@[\\w[.-]]+\\.[\\w]+&quot;); Matcher matcher=pattern.matcher(checkmainString); while(matcher.find()){//找到匹配的字符串，经数据放到group里面！ System.out.println(matcher.group()); } //注意：[\\w[.-]]表示的是一个大的数组，它是[\w . -]，就是由\w加上.-组成的新的组合范围！ } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射机制之深入理解]]></title>
      <url>%2F2017%2F05%2F02%2Fjava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[为什么使用动态代理在传统的静态代理设计模式里面，每个代理类只能为一个或者多个已经去确定的接口进行代理，在代理设计模式其实就是利用接口的多态性，由于实现的子类不一样，所以我们可以使得一个类成为代理类，让这个类可以实现真实类的一些业务。但是代理类和真实业务逻辑类都需要实现同一个接口，这就是静态代理设计的缺点，因为代理类受到了接口的限制。 动态代理设计模式这个其实利用的是java里面的反射机制，通过反射机制我们可以知道一个真实类实现了什么借口？这个真实类的类加载器是哪个，在代理类调用方法的时候，我们实现一个InvocationHandle接口,该接口是代理实例 调用处理程序 的实现接口（调用处理的一个程序，或者一个方法，其实就是一个方法，invoke()执行方法）下面讲解我们构建动态代理的三个主要的接口和类 Proxy这个类是所创建的动态代理实例的所有父类public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[]interfaces, InvocationHandler h)：该方法用于返回一个动态创建的代理类的实例，方法中第一个参数loader表示代理类的类加载器，第二个参数interfaces表示代理类所实现的接口列表（与真实主题类的接口列表一致），第三个参数h表示所指派的调用处理程序类。（这个类是实现了InvocationHandle接口的类，这个类要将真实类织入，当由这个Proxy产生的代理实例发生方法额调用的时候，它会将调用交给到这个调用程序处理类，让他来对调研进行处理） InvocationHandleInvocationHandler接口是代理处理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用处理者（InvocationHandler接口的子类）。在该接口中声明了如下方法：public Object invoke(Objectproxy, Method method, Object[] args)：该方法用于处理对代理类实例的方法调用并返回相应的结果，当一个代理实例中的业务方法被调用时将自动调用该方法。invoke()方法包含三个参数，其中第一个参数proxy表示代理类的实例，第二个参数method表示需要代理的方法，第三个参数args表示代理方法的参数数组。 动态代理类需要在运行时指定所代理真实主题类的接口，客户端在调用动态代理对象的方法时，调用请求会将请求自动转发给InvocationHandler对象的invoke()方法，由invoke()方法来实现对请求的统一处理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射机制]]></title>
      <url>%2F2017%2F05%2F01%2F%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[java反射机制反射机制就是在运行的状态下，通过一个类可以知道这个类的所有的属性和方法，或者通过一个类的对象可以调用它的任意一个属性和方法；这种动态获取信息及动态调用对象的方法和属性的功能就是反射机制（其实就是我们的属性.的时候自动跳出方法和属性供选择的这个功能。）说白了反射机制其实就是由小知大，既然你是某个类的对象，或者我知道了这个类的名字，那么我jvm就可以知道这个类的所有信息。这不是很正常吗？ 实例化的过程在正常情况下，实例化一个类是需要知道这个类的路径的，流程如下引入包–&gt;new 类名称–&gt;实例化完成反射机制的流程：类名称–&gt;类所在的路径 通过反射机制完成类的实例化 getName()方法获取类名称的使用：这个方法是Class类里面的，所以获取的流程如下： User u=new User(); u.getClass().getName(); Class的静态方法： Class&lt;?&gt; u=Class.forName(&quot;com.User&quot;); u.getName();//因为此时的u刚好是Class对象。所有所以不需要getClass(); CLass的newInstance()方法：` User1 tes2=u.getClass().newInstance();` Class类的使用获取Class实例的三种方式：运用.class的方式来获取Class实例。对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的Class实例。例如，Integer.TYPE 与 int.class是等效的，都是int。利用对象调用getClass()方法获取该对象的Class实例；使用Class类的静态方法forName()，用类的名字获取一个Class实例（static Class forName(String className) ），这种方式灵活性最高，根据类的字符串全名即可获取Class实例，可以动态加载类，框架设计经常用到；Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass方法自动构造的，因此不能显式地声明一个Class对象。虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。（JVM加载一个类的流程，查看虚拟机里面是否已经加载，如果没有，就去找对应的.class字节码文件进行加载，之后利用这个Class类的对象进行这个类的实例化操作。整个流程就一份.class字节码文件，一个类对应的Class对象，这个Class对象是JVM自行创建的。）java反射机制的深入研究 通过public Object invoke(Object obj,Object… args);可以调用特定的类里面的方法，只需要传入一个类的实例。注意Method的实例化如下：Method method=tes2.getClass().getMethod(&quot;sayHello&quot;, null);在实例化的时候要知道自己需要调用的方法的名称。注意这个方法的返回类型是Object，你需要自己将数据提取出来。 静态代理技术的实现：什么是代理技术？代理技术就是完成被代理对象所需要的业务，代理对象需要有代理很多对象的方法，也就是每个类的实例传进来后，可以动态的调用对应的方法实现需要的功能。所有代理对象需要实例化一个最大的接口，利用接口的多态性进行设计。被代理对象，代理对象都需要实现我们的同一个接口哦。代理对象在覆写我们的接口的方法的时候，需要将被代理对象需要的业务织入到覆写方法里面。 类加载器：对于java，我们的类加载器一共有三种类的加载。 由于静态代理技术在实现的时候，是指定了继承的类，也就是这个代理对只能代理一个接口，这样不好，如果有很多的接口需要代理的话，那么依旧解决不了代码的重用性，利用java的反射机制我们来实现动态的代理技术 动态代理技术的实现：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java反射机制]]></title>
      <url>%2F2017%2F05%2F01%2Fjava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B62%2F</url>
      <content type="text"><![CDATA[java反射机制反射机制就是在运行的状态下，通过一个类可以知道这个类的所有的属性和方法，或者通过一个类的对象可以调用它的任意一个属性和方法；这种动态获取信息及动态调用对象的方法和属性的功能就是反射机制（其实就是我们的属性.的时候自动跳出方法和属性供选择的这个功能。）说白了反射机制其实就是由小知大，既然你是某个类的对象，或者我知道了这个类的名字，那么我jvm就可以知道这个类的所有信息。这不是很正常吗？ 实例化的过程在正常情况下，实例化一个类是需要知道这个类的路径的，流程如下引入包–&gt;new 类名称–&gt;实例化完成反射机制的流程：类名称–&gt;类所在的路径 通过反射机制完成类的实例化 getName()方法获取类名称的使用：这个方法是Class类里面的，所以获取的流程如下： User u=new User(); u.getClass().getName(); Class的静态方法： Class&lt;?&gt; u=Class.forName(&quot;com.User&quot;); u.getName();//因为此时的u刚好是Class对象。所有所以不需要getClass(); CLass的newInstance()方法：` User1 tes2=u.getClass().newInstance();` Class类的使用获取Class实例的三种方式：运用.class的方式来获取Class实例。对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的Class实例。例如，Integer.TYPE 与 int.class是等效的，都是int。利用对象调用getClass()方法获取该对象的Class实例；使用Class类的静态方法forName()，用类的名字获取一个Class实例（static Class forName(String className) ），这种方式灵活性最高，根据类的字符串全名即可获取Class实例，可以动态加载类，框架设计经常用到；Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass方法自动构造的，因此不能显式地声明一个Class对象。虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。（JVM加载一个类的流程，查看虚拟机里面是否已经加载，如果没有，就去找对应的.class字节码文件进行加载，之后利用这个Class类的对象进行这个类的实例化操作。整个流程就一份.class字节码文件，一个类对应的Class对象，这个Class对象是JVM自行创建的。）java反射机制的深入研究 通过public Object invoke(Object obj,Object… args);可以调用特定的类里面的方法，只需要传入一个类的实例。注意Method的实例化如下：Method method=tes2.getClass().getMethod(&quot;sayHello&quot;, null);在实例化的时候要知道自己需要调用的方法的名称。注意这个方法的返回类型是Object，你需要自己将数据提取出来。 静态代理技术的实现：什么是代理技术？代理技术就是完成被代理对象所需要的业务，代理对象需要有代理很多对象的方法，也就是每个类的实例传进来后，可以动态的调用对应的方法实现需要的功能。所有代理对象需要实例化一个最大的接口，利用接口的多态性进行设计。被代理对象，代理对象都需要实现我们的同一个接口哦。代理对象在覆写我们的接口的方法的时候，需要将被代理对象需要的业务织入到覆写方法里面。 类加载器：对于java，我们的类加载器一共有三种类的加载。 由于静态代理技术在实现的时候，是指定了继承的类，也就是这个代理对只能代理一个接口，这样不好，如果有很多的接口需要代理的话，那么依旧解决不了代码的重用性，利用java的反射机制我们来实现动态的代理技术 动态代理技术的实现： public interface Subject { public void rent(); public String sayHello(String name); } 实现接口的需要被代理的类： public class RealSubject implements Subject { @Override public void rent() { // TODO Auto-generated method stub System.out.println(&quot;我是被代理对象里面的rent()方法&quot;); } @Override public String sayHello(String name) { // TODO Auto-generated method stub return &quot;我是被代理对象,我的名字是:&quot;+name; } } 代理对象的产生：使用的是实现了InvocationHandler接口的一个类 public class DynamicProxy implements InvocationHandler{ private Object subject;//需要被代理的对象 public DynamicProxy(Object subject) { this.subject = subject; } //这个方法会被Proxy生成的代理对象自动调用，也就是说，Proxy生成的代理对象调用对应的方法时候，我们这里的method就实例化成该方法的对象。 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // TODO Auto-generated method stub System.out.println(&quot;before rent()方法&quot;); System.out.println(&quot;Method方法是：&quot;+method); method.invoke(subject, args); return null; } //这类其实只是一个桥接工具，因为在newProxyInstance()的构造方法里面使用到； } 这个类我们其实就写了一个实例化而已。同时调用方法的实例method.invoke(代理对象的实例);这样其实就是将代理对象直接传到我们之前写的method对象的产生。接下来就是产生我们的动态代理对象，使用的是我们Proxy类提供的一个静态的方法，我们可以直接调用就行。具体代码如下： import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class TestDynamicProxy { public static void main(String[] args) { //1.找到需要代理的对象 Subject subject=new RealSubject(); InvocationHandler inHandler=new DynamicProxy(subject); Subject sub=(Subject)Proxy.newProxyInstance(inHandler.getClass().getClassLoader(), subject.getClass().getInterfaces(), inHandler); sub.rent(); sub.sayHello(&quot;林金福&quot;); RealSayBye realSayBye=new RealSayBye(); InvocationHandler inHandler2=new DynamicProxy(realSayBye); TestFace getIt=(TestFace)Proxy.newProxyInstance(inHandler2.getClass().getClassLoader(), realSayBye.getClass().getInterfaces(), inHandler2); getIt.sayBye(); } } Proxy实例的产生返回的是接口的实例，因此我们写的是接口而不是代理类！所以是（接口名）对象=（接口名）Proxy.newProxyInstance(实现了INvocationHandle接口的代理对象的类加载器,被代理对象的接口名称,实现了InvocationHandle接口的代理对象的实例)由于InvocationHandle接口的实现，我们的代理对象得的是被代理对象的 还有一点：可能我以为返回的这个代理对象会是Subject类型的对象，或者是InvocationHandler的对象，结果却不是，首先我们解释一下为什么我们这里可以将其转化为Subject类型的对象？原因就是在newProxyInstance这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是Subject类型，所以就可以将其转化为Subject类型了。同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。 接着我们来看看上面d代码里面的这两句subject.rent();subject.hello(“world”);这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的invoke方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的invoke方法去执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HashMap]]></title>
      <url>%2F2017%2F04%2F30%2FHashSet%2F</url>
      <content type="text"><![CDATA[entrySet() 方法Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射所包含的映射关系的 Set 视图。 其实我们可以这样理解，链表的产生就是因为我们的hash碰撞，一般的话，每个数据都会先被包装成Entry结构体，之后放到我们的HashSet里面，在HashSet里面其实都是table数组，一般如果没有碰撞就是每个索引最多只有一个元素Entry存在。但是当我们的hash发生碰撞的时候，我们的处理方式就是链表的的延伸，如果key值的hash发生碰撞并不一定表示我们的key是一样的，这时候我们还要比较的是equals方法。这样才可以判断这两个元素是不是一样的。总结，我们的数据是先被包装成Entry之后再放到HashSet里面的。 我们由三种方法来获取HashSet里面的数据 使用我们的迭代器Iterator,迭代器其实就是我们的Iterator接口提供的一个方法，使用这个方法我们可以单向的对Set里面的数据进行遍历。要注意的是我们在使用迭代器的时候，删除的操作只能使用迭代器提供的remove方法。否则会报错！具体代码如下：Iterator&lt;Entry&lt;String, User&gt;&gt; iterator=hashMap.entrySet().iterator(); while(iterator.hasNext()){ Entry&lt;String,User&gt; e=iterator.next(); System.out.println(e.getKey()+&quot;--&gt;&quot;+e.getValue().getName()); } 使用我们的foreach循环进行遍历，具体代码如下： Set&lt;Entry&lt;String,User&gt;&gt;set=hashMap.entrySet(); System.out.println(&quot;********************&quot;); for(Entry&lt;String, User&gt; e:set){ System.out.println(e.getKey()+&quot;--&gt;&quot;+e.getValue().getName()); } 利用size()函数结合get()函数可以进行遍历。 SortedMap接口这个接口和我们的SortedSet一样，可以对我们的Map元素进行排序，主要是按照我们的键的toString进行排序的。它的特有的方法是方法摘要 Comparator&lt;? super K&gt; comparator() 返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回在此映射中包含的映射关系的 Set 视图。 K firstKey() 返回此映射中当前第一个（最低）键。 SortedMap&lt;K,V&gt; headMap(K toKey) 返回此映射的部分视图，其键值严格小于 toKey。 Set&lt;K&gt; keySet() 返回在此映射中所包含键的 Set 视图。 K lastKey() 返回映射中当前最后一个（最高）键。 SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。 SortedMap&lt;K,V&gt; tailMap(K fromKey) 返回此映射的部分视图，其键大于等于 fromKey。 Collection&lt;V&gt; values() 返回在此映射中所包含值的 Collection 视图。 Sorted和Vevtor接口实现Sorted接口的类可以进行自动排序,它的特有方法就是获取第一个和最后一个以及在指定范围内的所有数据，而Vector接口是List接口的子接口，它的特有方法就是栈的操作，有获取栈顶元素，进栈出栈操作等，实现Vector的一个子类Stack就是进行栈操纵的一个类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[List接口的使用]]></title>
      <url>%2F2017%2F04%2F29%2F%E7%B1%BB%E9%9B%86%E4%B9%8Blist%E6%8E%A5%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[说一下Collection的作用类集和数组最大的区别就是，我们可以将类集看作是大小可变的数组，数组的大小在定义的时候就要求给定，但是类集是会动态的扩展自己的大小的。Collection接口 Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：Iterator it = collection.iterator(); // 获得一个迭代子while(it.hasNext()) {Object obj = it.next(); // 得到下一个元素}由Collection接口派生的两个接口仅为List和Set。 Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap此处要注意到我们的Maps是另外的接口，它是一个键值对的集合。 List接口的相关知识实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。为什么？这其实也是一种多态的设计模式，我们使用的是List对象，但是他的子类不同，所以得到的功能也会不同，这样就达到了统一的访问标准。（这个接口的调用的功能会随着你的实例化的不同而不同，不需要比去修改List对象）LinkedList类 LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list =Collections.synchronizedList(new LinkedList(…)); ArrayList类ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 Vector类Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。 Stack类Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 List接口各实现类的区别ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！ 同步性Vector是同步的。这个类中的一些方法保证了Vector中的对象是线程安全的。而ArrayList则是异步的，因此ArrayList中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用ArrayList是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销。 数据增长从内部实现机制来讲ArrayList和Vector都是使用数组(Array)来控制集合中的对象。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。 使用模式如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。在ArrayList和Vector中，从一个指定的位置（通过索引）查找数据或是在集合的末尾增加、移除一个元素所花费的时间是一样的，这个时间我们用O(1)表示。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行位移的操作。这一切意味着什么呢？这意味着，你只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是其他操作，你最好选择其他的集合操作类。比如，LinkList集合类在增加或移除集合中任何位置的元素所花费的时间都是一样的?O(1)，但它在索引一个元素的使用缺比较慢－O(i),其中i是索引的位置.使用ArrayList也很容易，因为你可以简单的使用索引来代替创建iterator对象的操作。LinkList也会为每个插入的元素创建对象，所有你要明白它也会带来额外的开销。最后，在《Practical Java》一书中Peter Haggar建议使用一个简单的数组（Array）来代替Vector或ArrayList。尤其是对于执行效率要求高的程序更应如此。因为使用数组(Array)避免了同步、额外的方法调用和不必要的重新分配空间的操作。尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。（注：）ArrayList接口还有一个addAll(Collection&lt;&gt;)方法，这个方法可以将这个collection里面的对象一次性都加到我们的ArrayList里面，也就是说是连个ArrayList集合的直接相加，增加效率。List的用法 添加元素，List有四种实现方法，我们可以根据情况来觉得我们的实现。有一个addAll(Collection)可以一次将一个collection的所有元素都加到List里面，效率高 移除元素，可以根据小标或者直接该对象删除 取数据，可以说，这个方法是最重要的，我们需要将放到这个集合里面的数据取出来有很多方法，一般使用的是迭代器和取得size()进行for循环。 一般迭代器的使用方法：iterator it=arraylist.iterator(); whhile(it.hasNext()){ object obj=it.next(); } 这样就可以获得所有的数据了； size()方法和get(index i)方法结合可以遍历所有元素：for(int i=0;i&lt;tlist.size();i++){ System.out.println(tlist.get(i)); } LinkedList这个接口其实就是增加了链表的一些方法而已，只要就是一个链表属性。它其中还有一些栈的方法，出栈等，栈顶元素等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RandomAccessFile类的使用]]></title>
      <url>%2F2017%2F04%2F26%2FIO%E7%B1%BB%E4%BA%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[使用RandomAccessFile操作文件内容这个类是对内容进行操作的，但是操作起来比较麻烦，所有做一定的了解就行；具体代码： package bufferReader; import java.io.IOException; import java.io.RandomAccessFile; public class RandomAccessFileTest { public static void main(String[] args) { RandomAccessFile ra=null; try { ra=new RandomAccessFile(&quot;e:\\myeclipse 2015 workplace\\testfile\\test5.txt&quot;, &quot;rw&quot;); //这一句会出现乱码，为什么？ ra.writeBytes(&quot;randomaccessfile的读写模式&quot;); ra.write(&quot;不会出现乱码&quot;.getBytes()); ra.writeBytes(&quot;hello world&quot;); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); }finally{ if(ra!=null){ try { ra.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } 说一下：流的概念，在程序里面，所有的数据都是以流的形式进行传输的，当内容需要数据的时候，就使用输入流读取数据，同样使用输出流将内存的数据保存到文件里面。InputStream,OutputSTraem是最大的字节流父类，但是他是抽象类，一次需要使用子类实例进行实例化。这个其实也就是这个类的设计了，使用到多态性。这个字节流可以将数据从流中读取和将数据写到流里面，但是无法操作我们的文件，这个也就是我们为什么实例化的时候使用到FilleInputStream/FileOutputStream这个子类的原因，使用多态性进行数据到文件的存储，中间的就是我们的流，其实就是将文件File的功能赋予到输入输出流。 对IO的理解 首先明白，流，文件操作是不一样的，jvm内存的数据都是以流的形式进行读取和存储的，也就说，程序需要的数据是从流里面读取，将数据缓存也是写到流里面的。流其实就是一个中间驿站，那么，流到文件以及文件到流的操作怎么实现？就是使用的FileInptStream和FileOutputStream进行操作，这两也是输入输出流的子类，利用多态性就可以使得输入输出流的对象可以进行数据到文件的操所（本来就是数据到流或者流到数据，文件类是文件到流和流到文件）；这个流其实是被装饰过了。IO里面体现了很多的设计模式，多态性是最显而易见的。 FileInputStream,就是将文件读取到流里面；之后我们如果想要得到文件里面的数据的话，就直接利用它这个类里面提供的方法就可以将数据写到指定的内容里面，inputstream就是写到字节数组里面；同理，我们的ByteArrayIputStream其实就是将数据读取到流里面，数据是”字节数组”类型，其实这个和File是一样的，XxxInputStream里面的Xxx前面就是数据类型。同理，ByteArrayOutputStream其实就是将数据写到流里面的对象。使用它提供的方法将需要写到字节数组的数据使用write(“需要的数据”.getBytes()); 从File和ByteArray这两个类其实就知道IO的设计模式了，就是将某个形式的数据读取或者写入到流里面，File的话就是将数据从文件里面读取写到流里面或者将数据从流里面写到文件，字节数组也一样。 我们其实还有一个类需要掌握，那就是InputStreamReader / OutputStreamWriter ,这个类支持将字节流转换成字符流。所以我们可以很简单的解决一些中文乱码的问题，一般来说，将字节读取后转换成字符会出现乱码，或者是受到字节数组的大小的限制，但是字符流的读取是没有这两个问题的，所以，当需要将我们的字节流读取变成我们的字符流的时候，最好就是使用我们的这个中间的类进行一下包装，使得我们的读取和存储没有乱码的问题。具体大代码在下面的例子里面就可以很好的体现出来了: 例子代码： package bufferReader; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; public class SystemTest { public static void main(String[] args) throws IOException { SystemTest st=new SystemTest(); st.getByGood(); } public void getByByte() throws IOException{ InputStream in=System.in;//从键盘读取数据输入 int temp=0; byte b[]=new byte[1024]; System.out.println(&quot;请输入内容！&quot;); while((temp=in.read(b))!=-1){ System.out.println(new String(b,0,temp)); } //次方法有缺陷，字节数组大小的限制以及中文乱码的限制（中文乱码是当字节数组是奇数的时候只读取一般的中文 ） } public void getByOther() throws IOException{ InputStream in=System.in;//从键盘读取数据输入 StringBuffer sb=new StringBuffer(); int temp=0; System.out.println(&quot;请输入内容！&quot;); while((temp=in.read())!=-1){ //0-255其实包括了我们的字母和所有的符号？所有可以将数字和字母或者符号进行等价 char c=(char)temp; if(c==&apos;\n&apos;){ break; } sb.append(c); } System.out.print(sb); //这个方法的缺陷就是中文输入会造成乱码。原因就是这个只能每次读取一个字节，也就inputstream这类本身方法的缺陷。 } public void getByGood() throws IOException{ BufferedReader buf=new BufferedReader(new InputStreamReader(System.in)); System.out.println(&quot;请输入内容：&quot;); System.out.println(buf.readLine()); //这个方法输入没有限制，没有中文乱码的问题。 //对于InputStream来说，其read要么受到字节数组大小的影响，要么每次只能读取一个字节，很是不方便.BufferedReader一次将数据直接读取到缓冲区，解决了意以上问题 } } 由这个Scanner的构造方法我们知道，这个工具很是强大，它可以直接扫面很多的文件类型，IO的操作基本都包括了。它简直就是一个神器，可以省了我们直接使用IO操作的很多麻烦]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Iterator接口的使用]]></title>
      <url>%2F2017%2F04%2F25%2FIterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%B2%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[迭代器（Iterator） 对 collection 进行迭代的迭代器。 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。 Java中的Iterator功能比较简单，并且只能单向移动： (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。 (2) 使用next()获得序列中的下一个元素。 (3) 使用hasNext()检查序列中是否还有元素。 (4) 使用remove()将迭代器新返回的元素删除。 Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。这个是一个轻量级的对象，它可以对connection类集进行单项移动迭代，达到遍历的效果，同时还能对某个元素进行删除。但是在实际中很少调用这个删除方法，一般是用来对类集进行遍历的，而且，注意不可以在迭代的时候，进行类集里面的操作，也就是调用List或Set的remove()方法，否则会出现错误！！也就是说在使用迭代器的时候只能使用iterator自己的remove方法。 Listiterator由于Iterator是单向的遍历，考虑到实际情况，我们还有一个ListIterator接口，这个接口可以实现双向输出，也就是多了hasPrevious()和previous() 这两个主要的由后向前移动的函数，打动双向遍历的效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Map接口的使用]]></title>
      <url>%2F2017%2F04%2F24%2FMap%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[Map知识点Map简介将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。此接口取代 Dictionary 类，后者完全是一个抽象类，而不是一个接口。Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。将键值对放到Map里面的工作是由Map.Entry这个接口进行的，它是一个静态接口，在这个接口里面只有五个方法，分别是 boolean equals(Object o) 比较指定对象与此项的相等性。 K getKey() 返回与此项对应的键。 V getValue() 返回与此项对应的值。 int hashCode() 返回此映射项的哈希码值。 V setValue(V value) 用指定的值替换与此项对应的值（可选操作）。 每次增加键值对的时候，都会调用这五个方法。由于不能有相同的键值，所有要判断键值是否相等，同时，一个键只能映射一个值。 Map的实现之HashMapHashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。 我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，它的工作原理就是这样：每次初始化一个HashMap的时候，就会初始化一个table数组，这个数组的元素都是entry节点，每个数组都是一个链表的索引。 首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。所以数组的索引其实就是一个链表的表头，通过表头我们可以遍历该链表的所有数据。Entry是HashMap的一个内部类，使用它的作用其实就是建立一个链表，每一个Entry都存了下一个节点的对象，也就是一个一个对象里存有下一个对象，这样就可以构成我们的链表。所有，在找打数组索引后，我们按照key的值进行链表的遍历排查，如果遍历链表（null链表也可以遍历！）key不重复，则将将加入的键值对作为链表的表头，将其他的元素挂在后面就可以了。如果存在相同的key，则将value的值覆盖就可以。 一是链的产生。这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。 二、扩容问题。随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 一开始的 transient Entry[] table = (Entry[]) EMPTY_TABLE;是一个空的数组？不是，如下：这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%（len-1）获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。这样，我们可以在一个很小的数组里面，存放很多的Entry(每个Entry有key,value,next)，如果hashCode不一样，那么即使存放在同一个数组下标下面，在存放的时候，key和value是不一样的，可以顺利操作，但是如果key的hashCode一样的话，那么会存放在相同的table[index]下，这时候有，由于hashCode一样，前面我们知道，要保证一个对象的不重复，不仅需要hashCode还有equals，其实equals才是最重要的，equals相等的话，两个对象一定是一样的，但是为了提高效率，hashCode不一样的时候，两个对象一定是不一样的（后面这句话可以提高效率，所有一般先比较hashcode，hashCode一样的时候，为了确保正确才使用equals!!）,所以，即使碰撞，我们由于equals的存在，可以很简单的解决。如果真的是同一个key，则直接覆盖value,否则就是一个新的Entry的简单加入，也就是链表的数据增加而已。 public V put(K key, V value) { if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } TreeMap这个其实和我们的Set里面的TreeSet一样，自定义的类使用的话，要实现Comparable接口，注意到这一点就可以。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Set接口的使用]]></title>
      <url>%2F2017%2F04%2F23%2FSet%2F</url>
      <content type="text"><![CDATA[Set介绍HashMap和HashSet里面的键值和对象的不相等在Java的集合中，判断两个对象是否相等的规则是： 判断两个对象的hashCode是否相等 如果不相等，认为两个对象也不相等，完毕 如果相等，转入2)（这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。后面会重点讲到这个问题。） 判断两个对象用equals运算是否相等 如果不相等，认为两个对象也不相等 如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键） HashMap不允许有相等的键值，HashSet不允许有相等的对象元素。说一下hashCode和equal的区别，其实我们的底层都是hashCode进行比较的，也就是说，一个对象的equals一样的话，那么它的哈市Code是一样的， @Override public int hashCode() { // TODO Auto-generated method stub return 一个int数; } @Override public boolean equals(Object obj) { // TODO Auto-generated method stub return this==obj; } 一般来说，我们的equals一样是，那么他们的地址是一样的（这是java规定的），但是如果他们的equals不相等的话，那么他们的hashCode不确定，为什么？因为hashCode的算法决定的。例如一个类的hashCode的算法是： @Override public int hashCode() { // TODO Auto-generated method stub return this.name.hashCode()+this.password.hashCode(); } @Override public boolean equals(Object obj) { // TODO Auto-generated method stub if(obj==null){ return false; } User user=(User)obj; if(obj==this){ return true; } if(this.name.equals(user.getName())&amp;&amp;this.password.equals(user.getPassword())){ return true; } return false; } hashCode返回一个int值，当自定义的时候就可能返回一个不一样的值。如果没有被覆写的话，那就返回的是哈希算法的结果。在我们覆写的方法里面，我们要按照jdk的要求，如果覆写了equals的话，那么hashCode是一定要覆写的，而且，如果equals相等的话，那么hashCode是一定要相等的。因为两个相等的对象的hashCode是一定一样的。当你使用HashSet的时候，add的时候调用的hashCode和equals是你覆写过的方法。总结：在使用Set的时候，保证两个元素是否相等的关键就是两个方法，hashCode和equals,一般是先比较hashCode，如果不相等，则两个对象不一样，如果相等，则进行equals的比较，如果一样则两个对象是一样的（同一内存的引用）。一般使用hashCode的原因是提高hashMap的效率和性能。所以，当我们的项目有要求的时候，我们是需要自己覆写hashCode和equals方法的。 HashSet和TreeSet使用HashSet的时候，将元素放到内存的时候，是乱序放入的，也就是和你的java语句的顺序是无关的，但是使用TreeSet的时候是会自动排序的。TreeSet的使用： 类要实现Comparable接口，覆写比较的方法 int compareTo(T o) @Override public int compareTo(User o) { System.out.println(&quot;比较方法被调用！&quot;); // TODO Auto-generated method stub int x= this.name.compareTo(o.getName()); if(x==0){ return this.password.compareTo(o.getPassword()); } return x; } 先比较什么，在再比较什么可由你自己决定。一个类实现了Comparable接口后，它的set就变得有序了，就算你使用的是HashSet，也不在是乱序插入。但是不是排序的，这一点和TrssSet还是有区别的。 TreeSet这个接口是谁TreeSet的子接口，使用SortedSet接口的子类是可以排序的子类，SortedSet的基本用法和TreeSet是一样的，在本章的例子里面我们主要就是熟悉一下其获取第一个和最后一个以及在两个在指定的元素之间的所有元素这三个方法。在前面我们知道，实现Set接口的类是不能有重复的元素存在的，这个的保证就是hashCode和equals方法，但是，set接口无法实现排序（既然所有元素不相等，我们可以考虑加入排序操作），所有就有了TreeSet接口，实现这个接口的时候记得覆写我们的comparableTo方法实现自己的排序规则。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[序列化]]></title>
      <url>%2F2017%2F03%2F30%2F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[IO编码问题 使用utf-8编码的说可以被gbk成功解码显示，没有乱码 使用iso8859-1编码的数据无法被gbk正确解码，出现中文乱码。对象的序列化 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。 把Java对象转换为字节序列的过程称为对象的序列化。 把字节序列恢复为Java对象的过程称为对象的反序列化。 对象的序列化主要有两种用途： 1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 2） 在网络上传送对象的字节序列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于使用hexo搭建自己的博客]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo%2F</url>
      <content type="text"><![CDATA[环境的搭建- 1.介绍：我们使用的这个博客生成器，其实是一个台湾大学生创建的，它的环境是主流的node.js,因此，我们需要先配置好node.js环境，node.js的安装自己百度就可以很快搞定，它有windows,linux，mac都有。使用这个hexo我们可以很简单的创建一个很炫酷的个人博客哦。 - 2.安装hexo:安装好node.js后，我们需要安装hexo,安装的指令是，在我们的命令窗口，输入： npm install hexo -g这个表示在这个环境里面安装好博客生成器。之后我们就可以使用简单的命令生成自己的博客了。 - 3.开始：首先，在一个文件夹里面，按住shift 后右键，选择在此打开cmd,输入：hexo init,这样就生成了一个简单的博客需要的所有配置文件，再使用hexo g这样就生成了一个博客，使用hexo s启动博客，在自己打的浏览器输入cmd里面的地址可以看到一个 HEXO 的博客页面。 修改自己的博客 1.搭建好自己的博客后，需要修改很多的内容来进行自己的优化，主要是修改两个配置文件，一个是站目录下面的配置文件，另外一个是主题目录下的配置文件。这两个文件的配置可以使得你的hexo主题改变很大。 2.站目录下的配置文件主要是配置我们项目发布到github的参数，在这个配置文件的最下面配置，注意我们使用的hexo版本，我使用的是3.0好像，这个版本在上传文件的时候，下面的代码： deploy: type: git repository: https://github.com/kingfou/kingfou.github.io.git branch: master 2.配置好后，将文件上传到我们的github上面，首先你要自己先在github上面注册和申请好自己的仓库，很简单的。自己百度。之后的操作就是：hexo d如果报错，请用github的 shell命令器cmd到自己的博客站目录下面 hexo d。如果提醒没有初始化什么的，直接git init,之后就可以了。 3.关于自己对主题的一些修改，这些都得在主题的那个配置文件里面自己一个一个慢慢设置，我使用的是next这款主题，十分炫酷。直接上next的官网就可以看到怎么修改一些内容。关于next主题1.介绍next我看过了hexo官方的很多主题，但是不太喜欢，最后遇到next，我觉得这个主题真的很好，虽然很多人在用，如果我的css够厉害的话，我们完全可以自己修改出很厉害的风格。所有，下面说说对这个主题的配置文件的一些修改吧。2.添加我们的本地搜索这个其实很简单，首先，修改站目录下的配置文件，将下面的代码写道配置文件的任何地方都可以：123456#站内搜索：search: path: search.xml field: post format: html limit: 10000 之后在主题的配置文件下面，找到那个local_search:123# Local searchlocal_search: enable: true 将enable 改为true即可。不过，我们还要做一件事，那就是在站目录下面加入一个插件，具体代码如下：1npm install hexo-generator-search --save 3.添加评论我们选择的是gengtie，也就是网易的云跟帖，这个真的不错，在next5.0以上的版本立面，我们只需要在主题得配置文件立面写上跟帖得idKEY就可以直接使用，也就是，一句代码得事。12 Gentie productKeygentie_productKey: 7e78cfd0046048efa69b351937e41a36 4.添加访问统计这里我使用得就是不蒜子这个第三方插件，配饰也很简单。就在主题文件立面修改就行。修改后如下。123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站访问游客 site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: 本文总阅读量 page_pv_footer: 次 设置全文阅读在主题配置文件立面写上：123auto_excerpt: enable: true length: 150 这样就可以使用了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO流的复习--文件的写入]]></title>
      <url>%2F2017%2F03%2F29%2FIO%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5%2F</url>
      <content type="text"><![CDATA[字节流的形式写入我们将需要写入的数据先得到其字节流数组后直接写入到我们的文件里面具体代码如下： //1.将数据写到我们的指定文件； OutputStream ot=new FileOutputStream(&quot;e:\\myeclipse 2015 workplace\\testfile\\test2.txt&quot;); ot.write(&quot;你好&quot;.getBytes()); 字符流的形式写入其实将文本或者其他写到文件的最好的就是使用我们的BufferedReader,使用这个BufferedReader还有一些需要注意的事情：具体代码如下： //2.字符流的形式直接写入 BufferedWriter br=new BufferedWriter(new FileWriter(&quot;e:\\myeclipse 2015 workplace\\testfile\\test3.txt&quot;)); br.write(&quot;你好&quot;); br.flush(); br.close(); 说一下注意事项：使用BufferedWriter 将内容写入文件，先开始少了wriite.flush()这句，发现无法写入内容。查资料后发现，原来BufferedWriter是缓冲输入流，意思是当你调用BufferedWriter的write方法时候。数据是先写入到缓冲区里，并没有直接写入到目的文件里。你必须调用BufferedWriter的flush()方法。这个方法会刷新一下该缓冲流，也就是会把数据写入到目的文件里。必须有这句的样子，实践中如果没有writer.flush(); 仅有writer.close();，会报异常。 所有的文件的写入，在没有该文件的时候会自动创建该文件，文件存在的话直接覆盖该文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh之值栈]]></title>
      <url>%2F2017%2F03%2F29%2Fssh%E6%95%B4%E5%90%88%E4%B9%8B%E9%A1%B5%E9%9D%A2%EF%BC%9A%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[1.pageContext.request.contextPath获得的是项目的名称。比如： /ssh_manager 前面有一个斜杠。 2.ssh的思想就是访问的是我们的action而不是直接的jsp，这样的话，你要学会在一个Action里面去处理很多的jsp请求。 3.模型驱动的值会默认放在值栈里面，而且，我们在一个Action里面有很多个方法的时候，每次访问一个方法的时候，就实例化一个Action,而且每个Action里面的值栈都是不一样的。 4.在jsp使用模型驱动里面的数据：1&lt;s:property value=&quot;model.属性&quot;&gt; 5.对值栈的理解：值栈就是一个栈，也就是数值是从顶到底读取的，不过它会自动帮我们去匹配，输出的是第一个匹配到的数据。==如果我们把一个对象放到值栈里面==：例如PageBean;123456789101112131415161718192021222324252627282930313233343536public class PageBean &lt;T&gt;&#123;//分页显示这个·相当于List&lt;E&gt; private int currPage;//当前页 private int pageSize;//每页显示 private int totalPage;//总页数 private int rowPage;//总记录 private List&lt;T&gt;list;//当前页面的数据 public int getCurrPage() &#123; return currPage; &#125; public void setCurrPage(int currPage) &#123; this.currPage = currPage; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public int getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public int getRowPage() &#123; return rowPage; &#125; public void setRowPage(int rowPage) &#123; this.rowPage = rowPage; &#125; public List&lt;T&gt; getList() &#123; return list; &#125; public void setList(List&lt;T&gt; list) &#123;//这个是从数据库得到的，上面的其他数据是提供给数据库的。 this.list = list; &#125; 之后在页面我们就可以使用一整个pageBean,包括里面的各个属性，而且可以直接使用属性的名字来获得该属性的值，它会在底层自动帮我们查找。而且还支持对list属性的iterator迭代。他会自动的将pageBean里面的list属性直接的给到我们的 注意：这个value要写对，要和pageBean里面的属性值一样。 2.对于页面单纯跳转到显示页面的做法：首先，对任何的jsp页面的请求，我们都是将请求给到我们的action进行处理的，这个的好处就是防止直接访问到我们的jsp，还有一个醉最大的好处就是，我们跳转到的页面需要的数据可以先在我们的Action里面直接准备好，这样jsp页面对java代码的耦合性就达到最低了。例如在员工系统里面，我们需要修改一个员工的信息，这时候我们的修改页面需要的数据有，该员工的所有原来的信息，这就要将该对象放到模型驱动里面，或者是值栈里面，接着，如果修改页面还需要所有部门以供选择的话，还要将所有部门的集合放到值栈里，这样在页面进行跳转后，我们的jsp页面就可以很直接的就得到我们在action里面为准备的所有的数据。直接利用==ognl==表达式就可以得到。 3.对于jsp页面请求的时候数据接收时发生错误会报出很多错误，其中就有一个是无法找到action,其实不是找不到，是它在为Action进行数据的封装的时候出现了错误而无法直接实例化我们得Action.特别是在使用了list集合的jsp页面，好像数据填写不完全就会报错，这个我也不是很懂。我的想法就是这个可以直接交给到我们的脚本进行判断，如果填写不符合规则就提交不了。很简单，不要后台进行处理。你还可以直接利用我们的ajax技术进行及时的提醒等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO流的复习--文件的读取]]></title>
      <url>%2F2017%2F03%2F29%2FIO%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%2F</url>
      <content type="text"><![CDATA[1.使用BufferedReader对文件进行读取使用这个类的好处是可以调用它的一个读取一行的方法。ReadLine();而且BufferedReader本来就是用来读取字符流的，这样可以直接避免中文乱码的出现。具体的代码如下: BufferedReader buf=new BufferedReader(new FileReader(&quot;e:\\myeclipse 2015 workplace\\testfile\\test1.txt&quot;)); //读取的是字符？ System.out.println(&quot;读取的内容如下&quot;); String str=&quot;&quot;; while(true){ str=buf.readLine(); if(str==null){ break; } System.out.println(str); } 使用FileInputStream读取文件这个其实是按照字节流的方式读取文件？我们的一个中文是两个字节，所以我们读取该文件的时候，要保证将该文件读取完全，需要知道字节数？ InputStream in=new FileInputStream(&quot;e:\\myeclipse 2015 workplace\\testfile\\test1.txt&quot;); byte b[]=new byte[1024]; in.read(b,0,2); System.out.println(new String(b)); 说一说装饰：（体验一下什么是装饰模式） 在这段代码中，沃我们只读取一个中文。注意到两个类在实例化的时候的区别，在第一个例子里面，我们使用的是一个中间的类:BufferedReader,它实现Reader(字符流的接口),在对它实例化的时候，我们使用的是 BufferedReader buf=new BufferedReader(new FileReader(&quot;filePath&quot;));这个FileReader也是 实现了Reader接口的，所以这个buf其实就是起到了一个装饰的作用，也就是说，一个老大有两个小弟：BufferedReader和FileReader;但是他们的功能不一样，例如BufferedReader不能直接读取文件，FileReader不能读取文件的一行。但是我们想要读取文件的一行，所有得赋予BUfferedReader读取文件的功能，这个就是装饰。也可以这样说，BufferedReader装饰了FileReader，使得它可以读取文件的一行。 分析这两种方式的区别一个是以字符流的方式读取的，速度快，简单便捷；另外一个是以字节流的方式读取的，其方法read(byte b[])是将数据按照字节流的方式读到我们的字节数组b里面的。这种方式最好用来读取我们的图片。其实也可以直接使用FileReader的文件读取方法来完成对文件的读取，它是将字符读取到我们的字符数组；（注意是字节读取到字节数组，字符读取到字符数组。） Reader r=new FileReader(&quot;e:\\myeclipse 2015 workplace\\testfile\\test1.txt&quot;); char []c=new char[8]; r.read(c); System.out.println(new String(c)); 将数据读取到字符数组里面和字节数组里一样很麻烦，所有我们采用的BufferedReader对我们的FileReader进行装饰。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh总结1]]></title>
      <url>%2F2017%2F03%2F10%2Fssh%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[1.理解：我们在项目里，本来是有三个配置文件要写的， 1.struts.xml：负责对action和访问的Action进行匹配，并且会根据Action的返回结果进行页面的跳转操作，在struts.xml里面，要注意的就是跳转的形式，result type的取值又很多，比如我们的json形式就是加入json插件又的一种同时，在struts.xml里面，我们还要注意的是action对Action里面方法的访问的写法；struts里面也定义了很多的拦截器，如果我们使用了自定义的拦截器的话，那么在访问该Action的时候，我们需要手动的去调用默认的拦截器栈。还有就是我们的常量的配置，可以起到很多的作用，比如自定义的错误消息的提醒，启用一些其他属性。这个可以查我们的default-struts这个配置文件，里面又所有的常量。 2.applicationContext.xml：1.这个配置文件是我们spring里面的配置文件，它的作用就是进行bean的注入，EJB,企业级java bean ，也就是说，将对bean的实例化等操作直接在配置文件里面完成。在ssh里面，我们也是直接的使用这个bean.xml来对我们的struts.xml和beans.xml进行整合的；1.对struts进行整合，就是将Action类的实例化的工作直接交给到我们的beans.xml，这时候在配置我们的action的时候，class=”id”,这个id就是我们在beans..xml里面的id,2.对hibernate进行整合：我们会将hibernate配置文件的内容直接都在这个beans.xml里面进行配置，这时候，我们的Dao类需要继承一个类，HibernateDaoSupport类，这个类继承后需要我们在beans.xml里面进行一些属性的配置，毕竟是继承来的，有很多的属性是需要配置的。 1.配置数据源，数据源可以写在一个新的peoperties文件里，我们在beans.xml里面直接读取赋值就可以，beans.xml读取其他的配置文件时候，要加入一个常量的配置： &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; 这句话表示我们会加载src目录下面的配置文件，之后对数据源进行配置，内容如下： ` 注意这个bean的包所在；就是我们引进来c3p0的jar包； 2.配置sessionFactory会话工厂：也就是对数据库的最高级操作，这个是一个重量级的 对象，一般我们只会实例化一次， 之后，它就接管数据库的链接管理， 使用数据库的时候，直接调用它提供的openSession()就可以得到一次岁数据库的操作。。 注意这个bean里需要配置以下三个属性值： 1.dataSource: 2.hibernateProperties:这个文件主要配饰hibernate对于的数据库类型和sql语句的一些显示，表的自动创建等： 由于这些属性是本来就存在的，因此我们属于的是properties文件的属性的注入形式： &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;/props&gt; 3.mappingResources:这个配置的是我们的domain类的关系映射文件，由于关系映射文件有多个， 因此需要用&lt;list&gt;标签列出来： &lt;list&gt; &lt;value&gt;com/imooc/domain/Product.hbm.xml&lt;/value&gt; ..... &lt;/list&gt; 12 接下来我们讲一下，为什么在继承了HibernateDaoSupport这个类的时候，我们就要去配置这个sesionFactory这个类：首先查看我们的HibernateDaoSupport的源码，我们知道，在这个源码里，它提供了一个HibernateTemplate对象，这个就是我们在dao进行hibernate操作的根本。但是这个对象的实例化，也就是创建,需要传入一个sessionFactory,它里面有这个sessionFactory的setter方法了，我们可以在beans.xml里面直接注入就行。整个流程：1.使用HibernateDaoSupport需要配置一个bean-sessionFactory,这个bean在hibernate核心包里面，这个类里面我们要配置三个属性：数据源，hibernateProperties,mappingResource这三个属性，其中，由于hibetrnateProperties的属性是存在的，采用的是props标签，而mappingResource里的关系映射文件是用list标签来写的。 3.hibernate.cfg.xml：这个文件虽然被beans.xml整合了，但是独立的话，它的作用就是配置数据源，配置数据库的类型，配置数据库sql语言，管理关系映射文件。之后在类里通过加载这个配置文就可以得到一个sessionFactory了。12 总结：总的来说，我们最好的整合方法就是将所有的类的实例化，属性的注入等工作交给beans.xml文件，这时候，我们的hibernate的配置等全部是在这个文件立面完成的，也就是说没有了hibernate.cfg.xml文件，而action的关系映射就直接在struts.xml立面完成。使用struts和spring之前，在web.xml立面，也有很重要的配置需要记住，那就是：1.struts核心过滤器的配置： &lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2.spring 监听器的配置： &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 说说这个ContextLoaderListener的作用：它的作用就是在web启动的时候 自动的去加载我们的beans.xml配置文件，不过在默认的情况下下， 他会去加载WEB-INFO下面的applicationContext.xml这个配置文件 ，因此，如果我们的配置文件在src目录下的话，我们就需要制定加载配置文件的所在路径，需要使用到下面的标签： &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; ```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义错误消息]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A02%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E6%B6%88%E6%81%AF%EF%BC%89%2F</url>
      <content type="text"><![CDATA[1.ServletActionContext.getServletContext().getRealPath(“/“)可以直接获得当前项目的真实路径。 一个result代表了一个可能的输出。当Action类的方法执行完成时，它返回一个字符串类型的结果码，框架根据这个结果码选择对应的result，向用户输出。在com.opensymphony.xwork2.Action接口中定义了一组标准的结果代码，可供开发人员使用，当然了只有我们的action继承ActionSupport 这个类才可以使用下面的结果代码，如下所示： 12345678public interface Action&#123; public static final String SUCCESS = “success”; public static final String NONE = “none”; public static final String ERROR = “error”; public static final String INPUT = “input”; public static final String LOGIN = “login”;&#125; 其中 Struts2应用在运行过程中若发现addFieldError()中有信息或者类型转换失败或着输入校验失败等情况那么它会自动跳转到name为input的1&lt;result/&gt; ，然后转到INPUT所对应的页面若JSP页面中表单是用普通编写的，发生错误而返回该页面时，则原数据将消失若JSP页面中表单是用编写的，发生错误而返回该页面时，则原数据仍存在若没有提供name值为input的，那么发生错误时，将直接在浏览器中提示404错误 除了这些预定义的结果码外，开发人员也可以定义其它的结果码来满足自身应用程序的需要。 3.由上面的笔记我们可以知道，默认的返回字符串是success,input,error,none,login这些。。。 3.修改默认的消息返回配置： 4.在我们的struts的核心包下面有一个配置文件default-properties,这个配置文件是无法直接修改的，但是里面是我们可以配置的所有的常量的集合，我们在struts,xml文件里面配置的常量其实在这里是全部可以直接找到的。在这下面还有很多的配置文件，比如struts-message这个配置文件，里面就有当信息出错是加载的常量属性。struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} “{1}” “{2}” {3} 这一段是在类型不允许的时候显示的，其中，0,1,2,3是文件的详细情况。文件名和文件类型什么的。我们写了一个配置文件赋值给一个常量，1&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;msg&quot;&gt;&lt;/constant&gt; 这个配置文件完成的时候，他会把struts-message里面的1struts.messages.error.content.type.not.allowed=Content-Type not allowed: &#123;0&#125; &quot;&#123;1&#125;&quot; &quot;&#123;2&#125;&quot; &#123;3&#125; 直接换成msg.properties下面的代码1struts.messages.error.content.type.not.allowed=\u60A8\u4E0A\u4F20\u7684\u6587\u4EF6\&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;\u7C7B\u578B\u6709\u8BEF 这一切，其实就是将一个常量直接等于一个配置文件，配置文件自己再为常量赋值？？？？ 5.每次使用自己写的拦截器的时候，一定要自己再手动加默认的拦截器栈。 6.文件上传的时候，对文件的格式，文件的大小一起其他的限制，我们可以直接在fileUpload这个拦截器里面直接配置好就行，必要的时候，可以自己配置文件不符合限制的时候的提示消息，这个消息的常量在我们的struts-messgae里面找到对应的属性，将此属性直接在自己写的配置文件里赋给新的提示消息值，之后将此配置文件赋值给对应的常量。 具体流程： 121.找到struts-message文件里面对应的属性，例如文件类型错误：struts.messages.error.content.type.not.allowed 122.将此属性copy到自己的配置文件里重新赋值：struts.messages.error.content.type.not.allowed=？？？？？ 12343.在我们的struts.xml配置文件里配置常量：&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;msg&quot;&gt;&lt;/constant&gt;这个msg就是我们自己的消息提示配置文件，我们将这个配置文件赋值给到这个常量就行。 14.这样当文件不符合的时候就会提示我们自定义的消息了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2实现ajax]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E5%AE%9E%E7%8E%B0Ajax%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[1.Ajax是什么，怎么实现？ 使用JQuery的方法实现 使用html的方法实现 JSON:在JQuery里面，我们提供了两种实现的方法 load(URL,data,callback);其url是请求的url，也就是要访问的服务的地址，data是请求的参数，可以为空，也可以带请求参数，最后的是一个回调函数，请求的数据直接放在回调函数里面。回调函数的构造类型如下：1234可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：responseTxt - 包含调用成功时的结果内容statusTXT - 包含调用的状态xhr - 包含 XMLHttpRequest 对象 2.$.get(URL,callback); 这是使用jquery的方法写的ajax,回调函数的使用如下： 12function(data,status)第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。 $.post(URL,data,callback);这个的用法和get是一样的，只是它可以带有自己的请求参数，也就是将页面的某个属性直接赋值后请求，例如直接请求id是多少的某个属性。 2.使用我们的struts实现ajax的时候，要手动导入另外的两个包。一个是struts提供的JSON插件支持包，另外一个就是JSON的包，它提供将对象直接字符串化的方法，这样才可以直接在action里面放回字符串的请求结果。此外，我们的struts配置内容如下：1234567&lt;package name=&quot;root1&quot; namespace=&quot;/&quot; extends=&quot;json-default&quot; &gt;&lt;!-- 实现AJAX的Action配置 --&gt; &lt;action name=&quot;ajax&quot; class=&quot;com.imook.action.AjaxAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;json&quot;&gt;&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 这里的json-default包其实就是我们的struts-josn的插件。这个是请求的数据是对象的时候； 3.请求的是集合的时候。其实原理是一样的，就是请求后在html页面得到的那个数据其实四一个集合的字符串，我们可以先得到该对象，之后进行遍历就可以得到我们想过的数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2文件上传]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[1.文件上传是在表单中完成的。表单提交到一个action里面，在action里面，我们开始对提交的文件进行操作。2.两个重要的属性的setter和getter，我们在html页面写的file 标签的名字要和Action里的名字是对应的。比如 123&lt;form method=&quot;post&quot; action=&quot;url&quot; enctype=&quot;multipart/form-data&quot;&lt;input type=&quot;file&quot; name=&quot;newname&quot;/&gt;&lt;/form&gt; 这样的话，我们可以得到上传文件的类型和名称，其中属性： 12- 1.newnameFileName(html的名字+FileName) - 2.newnameContentType(html的名字+ContentType) 这样就可以直接获取上传文件的名称和类型。 2.Action代码：1234 private File photo;private String photoFileName;private String photoContentType; html代码：1234&lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 文件上传：&lt;input type=&quot;file&quot; name=&quot;photo&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt;&lt;/form&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Action三种获取表单的模式]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%20Action%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[1.我们写的Action当继承了ActionSupport的时候，它会自动获取提交到该action的请求里面的表单数据，会缓存起来，如何获取呢？它的底层已经利用架构或者其他的配置文件，doj4等技术，只要我们的Action类里的属性名和表单的name标签的名字一样的时候，同时在Action里的属性有setter和getter的时候会自动获取，这个和我们的Spring的依赖注入很类似。2.通过一个implements ModelDriven接口来实例化封装的表单的数据。 3.详细解释： 域驱动：就是将表单的属性名称在action里面按照依赖注入的形式填充完成，这时候的成功因素就是Action里面的属性要和表单的name属性一致 属性驱动，所谓的属性驱动就是先将表单的提交信息封装好，成一个pojo，我们在action里的属性现在就是pojo,设置好pojo的setter和getter就行，在jsp页面写的就是pojo实例的属性。例如： `private User user;setter;getter; form;//表单形式name=”user.name”;name=”user.password” POJO://POJO类 User{ name; password; }` 表单的user会自动去寻找Action对应的属性user的，就是表单逆向寻找Action的属性。 3.模型驱动，modelDriven接口的实现，我们一开始就实现接口:`implements ModelDriven{private User user; Uer getModel(){//覆写方法if(user==null){ user=new User(); } }}`//这样就是自动的驱动我们的模型完成数据填充。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh之配置文件理解]]></title>
      <url>%2F2017%2F03%2F02%2Fssh%E4%B9%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[配置文件的理解 1.struts.xml：负责对action和访问的Action进行匹配，并且会根据Action的返回结果进行页面的跳转操作，在struts.xml里面，要注意的就是跳转的形式，result type的取值又很多，比如我们的json形式就是加入json插件又的一种同时，在struts.xml里面，我们还要注意的是action对Action里面方法的访问的写法；struts里面也定义了很多的拦截器，如果我们使用了自定义的拦截器的话，那么在访问该Action的时候，我们需要手动的去调用默认的拦截器栈。还有就是我们的常量的配置，可以起到很多的作用，比如自定义的错误消息的提醒，启用一些其他属性。这个可以查我们的default-struts这个配置文件，里面又所有的常量。 2.applicationContext.xml：1.这个配置文件是我们spring里面的配置文件，它的作用就是进行bean的注入，EJB,企业级java bean ，也就是说，将对bean的实例化等操作直接在配置文件里面完成。在ssh里面，我们也是直接的使用这个bean.xml来对我们的struts.xml和beans.xml进行整合的；1.对struts进行整合，就是将Action类的实例化的工作直接交给到我们的beans.xml，这时候在配置我们的action的时候，class=”id”,这个id就是我们在beans..xml里面的id,2.对hibernate进行整合：我们会将hibernate配置文件的内容直接都在这个beans.xml里面进行配置，这时候，我们的Dao类需要继承一个类，HibernateDaoSupport类，这个类继承后需要我们在beans.xml里面进行一些属性的配置，毕竟是继承来的，有很多的属性是需要配置的。 1.配置数据源，数据源可以写在一个新的peoperties文件里，我们在beans.xml里面直接读取赋值就可以，beans.xml读取其他的配置文件时候，要加入一个常量的配置： &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;这句话表示我们会加载src目录下面的配置文件，之后对数据源进行配置，内容如下：&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; ` &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; `]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[strut2拦截器]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%20%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
      <content type="text"><![CDATA[1.拦截器和过滤器本质上是一一样的。只是拦截器是一个一个按照顺序执行的，而过滤器则是按照配匹配的方式执行的。 2.struts2的架构实现就是依赖大量的拦截器来实现的。例如prepare ，fileupload,什么的，它会自动的将表单的数据直接封装成我们的Action类，我们就可以直接在Action里面使用了，这底层的机制就是依赖注入。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文件上传的限制]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[1.限制上传的文件大小可以直接在我们的fileUpload拦截器里直接配置好属性就可以fileUpload的属性如下：12345&lt;interceptor-ref=&quot;fileUpload&quot;&gt; &lt;param name=&quot;maximumSize&quot;&gt; 1024*1024; &lt;/param&gt;&lt;/interceptor&gt; 2.由于文件上传的时候，自己也会有一个默认的最大值，那个就是2M，这个时候，我们还是要修改一个常量，那就是struts.multipart.maxSize1&lt;constant name=&quot;struts.multipart.maxSize&quot; value=&quot;5242880&quot;&gt;&lt;/constant&gt; 3.文件下载：12345678910contentType内容类型，和互联网MIME标准中的规定类型一致，例如text/plain代表纯文本，text/xml表示XML，image/gif代表GIF图片，image/jpeg代表JPG图片inputName下载文件的来源流，对应着action类中某个类型为Inputstream的属性名，例如取值为inputStream的属性需要编写getInputStream()方法contentDisposition文件下载的处理方式，包括内联(inline)和附件(attachment)两种方式，而附件方式会弹出文件保存对话框，否则浏览器会尝试直接显示文件。取值为：attachment;filename=&quot;struts2.txt&quot;，表示文件下载的时候保存的名字应为struts2.txt。如果直接写filename=&quot;struts2.txt&quot;，那么默认情况是代表inline，浏览器会尝试自动打开它，等价于这样的写法：inline; filename=&quot;struts2.txt&quot;bufferSize下载缓冲区的大小。在这里面，contentType属性和contentDisposition分别对应着HTTP响应中的头Content-Type和Content-disposition头。 4.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HQL语句]]></title>
      <url>%2F2017%2F02%2F22%2FHQL%20%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[复习hibernate 的配置文件的写法： 回忆配置文件的配置顺序：数据库部分：在这一部分，我们的配置顺序就是按照前面的图进行配置，主要的参数有1234567891011121314151617181920&lt;!--配置数据库--&gt;connection.driver_classconnection.urlconnection=usernameconnection=userpassword&lt;!-- 配置使用的是什么数据库 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 配置sql语句的一些属性 --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 读取配置好的表格的属性 --&gt; &lt;mapping resource=&quot;com/imooc/domain/User.hbm.xml&quot;/&gt; &lt;mapping resource=&quot;com/imooc/domain/Goods.hbm.xml&quot;/&gt; &lt;mapping resource=&quot;com/imooc/domain/Paper.hbm.xml&quot;/&gt; &lt;!--在上面的sql语句配置中，show_sql表示输出实现时候的sql语句，hbm2ddl.auto则表示的是自动按照映射文件生成表格。--&gt; 加载配置文件：配置文件默认是在src目录下面的，如果不在根目录下面，则加载的时候要写全路径，也就是在src下面的==全路径==。 ######关系映射文件里面的one-to-many 和many-to-one: 首先确定好是一对多还是多对一，多的那个需要有外键，外键的参数就是那个一的主键。也就是==多==的这个里面的外键其实是==一==那个的主键。这时候，在创建表格的时候，我们这样考虑，其实多这个表的创建是需要一这个表的主键作为外键的。因此，我们需要注意顺序，就是先写的资源是==一==的那个，之后再写多的那个。这就可以解释我们在配置==一==那个表的关系映射文件的时候，为什么在配置set的时候有那么多的参数要配置，为的就是可顺利创建==多==的那个表格。 123456&lt;set name=&quot;domain里面的属性名称&quot;&gt;&lt;key column=&quot;user_id&quot;&gt;&lt;!--作为别人的外键--&gt;&lt;one-many class=&quot;对应的类&quot;/&gt;&lt;/set&gt;其实一个类对应一个表格，因此它可以寻找到该表格的。可以这样想：其实是按照你给到的类，对应到表格，在对应到表格的具体栏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2拦截器]]></title>
      <url>%2F2017%2F02%2F20%2Fstruts2%20%E5%81%9A%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%2F</url>
      <content type="text"><![CDATA[1.由于struts2的拦截器只对我们的action请求起到拦截作用，因此，我们完全可以直接访问jsp页面而不被拦截，但是如果我们的jsp是放在WEB-INF下面的话，我们则可以解决此问题2.拦截器拦截的原理是，判断session里是否已经有了登录信息，有则放行，invocation.invocate();这个方法表示比可以继续访问我们的action了，这个action是在struts里的配置，它是先找到struts.xml配置，再找到对象的Action的，当然，Action也可能不存在，直接做页面的跳转工作就行。3.拦截器的使用注意：使用自定义的拦截器的时候，默认的拦截器是关闭的。这是在访问这个action的时候发生的，也就是当你在访问此action的时候，如果你使用了自定义拦截器的话，那么在智执行这个action访问的时候只会调用你定义的拦截器，默认的拦截器是关闭的，除非你在此之前显式调用。4.由于默认拦截器比较多，一般我们自己应以一个拦截器栈，将默认拦截器栈先放进去，再放我们的自定义拦截器就形成我们自己的拦截器栈。 5.详细说明见链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[欢迎来到我的博客]]></title>
      <url>%2F2017%2F02%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[欢迎来到我的个人博客，在这里你可以看到我日常学习的笔记还有生活的点点滴滴，通过这个博客你可以认识到我，了解到我。希望大家一起互相学习，共同进步。 博客内容日记123我的博客中，有日志这个分类。我会将我日常的生活的点点滴滴直接写在这里，将自己的成才历程和大家一起分享哦。 笔记1笔记的话，我会在学习的过程中，将遇到的问题，解决方法，解决方法后的感受等都记录在我的博客里面。我觉得写笔记是一个很好的习惯，说不定你遇到的问题刚好我就解决了呢？这样效率就提高了。还有，记笔记是一个不断的记录自己成长的过程。所以，每一份笔记我们都要好好的对待。 More info: Server 个人情况12这个主要就是介绍我自己而已。。。。希望大家能喜欢我的博客。 More info: Generating 随笔12就记录自己平时的心情咯，自己的一些想法什么的。文艺的，小清新的什么都可以找到的到。]]></content>
    </entry>

    
  
  
</search>
