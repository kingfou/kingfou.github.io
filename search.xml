<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[HashMap]]></title>
      <url>%2F2017%2F04%2F30%2FHashSet%2F</url>
      <content type="text"><![CDATA[entrySet() 方法Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射所包含的映射关系的 Set 视图。 其实我们可以这样理解，链表的产生就是因为我们的hash碰撞，一般的话，每个数据都会先被包装成Entry结构体，之后放到我们的HashSet里面，在HashSet里面其实都是table数组，一般如果没有碰撞就是每个索引最多只有一个元素Entry存在。但是当我们的hash发生碰撞的时候，我们的处理方式就是链表的的延伸，如果key值的hash发生碰撞并不一定表示我们的key是一样的，这时候我们还要比较的是equals方法。这样才可以判断这两个元素是不是一样的。总结，我们的数据是先被包装成Entry之后再放到HashSet里面的。 我们由三种方法来获取HashSet里面的数据 使用我们的迭代器Iterator,迭代器其实就是我们的Iterator接口提供的一个方法，使用这个方法我们可以单向的对Set里面的数据进行遍历。要注意的是我们在使用迭代器的时候，删除的操作只能使用迭代器提供的remove方法。否则会报错！具体代码如下：Iterator&lt;Entry&lt;String, User&gt;&gt; iterator=hashMap.entrySet().iterator(); while(iterator.hasNext()){ Entry&lt;String,User&gt; e=iterator.next(); System.out.println(e.getKey()+&quot;--&gt;&quot;+e.getValue().getName()); } 使用我们的foreach循环进行遍历，具体代码如下： Set&lt;Entry&lt;String,User&gt;&gt;set=hashMap.entrySet(); System.out.println(&quot;********************&quot;); for(Entry&lt;String, User&gt; e:set){ System.out.println(e.getKey()+&quot;--&gt;&quot;+e.getValue().getName()); } 利用size()函数结合get()函数可以进行遍历。 SortedMap接口这个接口和我们的SortedSet一样，可以对我们的Map元素进行排序，主要是按照我们的键的toString进行排序的。它的特有的方法是方法摘要 Comparator&lt;? super K&gt; comparator() 返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回在此映射中包含的映射关系的 Set 视图。 K firstKey() 返回此映射中当前第一个（最低）键。 SortedMap&lt;K,V&gt; headMap(K toKey) 返回此映射的部分视图，其键值严格小于 toKey。 Set&lt;K&gt; keySet() 返回在此映射中所包含键的 Set 视图。 K lastKey() 返回映射中当前最后一个（最高）键。 SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。 SortedMap&lt;K,V&gt; tailMap(K fromKey) 返回此映射的部分视图，其键大于等于 fromKey。 Collection&lt;V&gt; values() 返回在此映射中所包含值的 Collection 视图。 Sorted和Vevtor接口实现Sorted接口的类可以进行自动排序,它的特有方法就是获取第一个和最后一个以及在指定范围内的所有数据，而Vector接口是List接口的子接口，它的特有方法就是栈的操作，有获取栈顶元素，进栈出栈操作等，实现Vector的一个子类Stack就是进行栈操纵的一个类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[List接口的使用]]></title>
      <url>%2F2017%2F04%2F29%2F%E7%B1%BB%E9%9B%86%E4%B9%8Blist%E6%8E%A5%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[说一下Collection的作用类集和数组最大的区别就是，我们可以将类集看作是大小可变的数组，数组的大小在定义的时候就要求给定，但是类集是会动态的扩展自己的大小的。Collection接口 Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：Iterator it = collection.iterator(); // 获得一个迭代子while(it.hasNext()) {Object obj = it.next(); // 得到下一个元素}由Collection接口派生的两个接口仅为List和Set。 Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap此处要注意到我们的Maps是另外的接口，它是一个键值对的集合。 List接口的相关知识实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。为什么？这其实也是一种多态的设计模式，我们使用的是List对象，但是他的子类不同，所以得到的功能也会不同，这样就达到了统一的访问标准。（这个接口的调用的功能会随着你的实例化的不同而不同，不需要比去修改List对象）LinkedList类 LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list =Collections.synchronizedList(new LinkedList(…)); ArrayList类ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 Vector类Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。 Stack类Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 List接口各实现类的区别ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！ 同步性Vector是同步的。这个类中的一些方法保证了Vector中的对象是线程安全的。而ArrayList则是异步的，因此ArrayList中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用ArrayList是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销。 数据增长从内部实现机制来讲ArrayList和Vector都是使用数组(Array)来控制集合中的对象。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。 使用模式如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。在ArrayList和Vector中，从一个指定的位置（通过索引）查找数据或是在集合的末尾增加、移除一个元素所花费的时间是一样的，这个时间我们用O(1)表示。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行位移的操作。这一切意味着什么呢？这意味着，你只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是其他操作，你最好选择其他的集合操作类。比如，LinkList集合类在增加或移除集合中任何位置的元素所花费的时间都是一样的?O(1)，但它在索引一个元素的使用缺比较慢－O(i),其中i是索引的位置.使用ArrayList也很容易，因为你可以简单的使用索引来代替创建iterator对象的操作。LinkList也会为每个插入的元素创建对象，所有你要明白它也会带来额外的开销。最后，在《Practical Java》一书中Peter Haggar建议使用一个简单的数组（Array）来代替Vector或ArrayList。尤其是对于执行效率要求高的程序更应如此。因为使用数组(Array)避免了同步、额外的方法调用和不必要的重新分配空间的操作。尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。（注：）ArrayList接口还有一个addAll(Collection&lt;&gt;)方法，这个方法可以将这个collection里面的对象一次性都加到我们的ArrayList里面，也就是说是连个ArrayList集合的直接相加，增加效率。List的用法 添加元素，List有四种实现方法，我们可以根据情况来觉得我们的实现。有一个addAll(Collection)可以一次将一个collection的所有元素都加到List里面，效率高 移除元素，可以根据小标或者直接该对象删除 取数据，可以说，这个方法是最重要的，我们需要将放到这个集合里面的数据取出来有很多方法，一般使用的是迭代器和取得size()进行for循环。 一般迭代器的使用方法：iterator it=arraylist.iterator(); whhile(it.hasNext()){ object obj=it.next(); } 这样就可以获得所有的数据了； size()方法和get(index i)方法结合可以遍历所有元素：for(int i=0;i&lt;tlist.size();i++){ System.out.println(tlist.get(i)); } LinkedList这个接口其实就是增加了链表的一些方法而已，只要就是一个链表属性。它其中还有一些栈的方法，出栈等，栈顶元素等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RandomAccessFile类的使用]]></title>
      <url>%2F2017%2F04%2F26%2FIO%E7%B1%BB%E4%BA%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[使用RandomAccessFile操作文件内容这个类是对内容进行操作的，但是操作起来比较麻烦，所有做一定的了解就行；具体代码： package bufferReader; import java.io.IOException; import java.io.RandomAccessFile; public class RandomAccessFileTest { public static void main(String[] args) { RandomAccessFile ra=null; try { ra=new RandomAccessFile(&quot;e:\\myeclipse 2015 workplace\\testfile\\test5.txt&quot;, &quot;rw&quot;); //这一句会出现乱码，为什么？ ra.writeBytes(&quot;randomaccessfile的读写模式&quot;); ra.write(&quot;不会出现乱码&quot;.getBytes()); ra.writeBytes(&quot;hello world&quot;); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); }finally{ if(ra!=null){ try { ra.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } 说一下：流的概念，在程序里面，所有的数据都是以流的形式进行传输的，当内容需要数据的时候，就使用输入流读取数据，同样使用输出流将内存的数据保存到文件里面。InputStream,OutputSTraem是最大的字节流父类，但是他是抽象类，一次需要使用子类实例进行实例化。这个其实也就是这个类的设计了，使用到多态性。这个字节流可以将数据从流中读取和将数据写到流里面，但是无法操作我们的文件，这个也就是我们为什么实例化的时候使用到FilleInputStream/FileOutputStream这个子类的原因，使用多态性进行数据到文件的存储，中间的就是我们的流，其实就是将文件File的功能赋予到输入输出流。 对IO的理解 首先明白，流，文件操作是不一样的，jvm内存的数据都是以流的形式进行读取和存储的，也就说，程序需要的数据是从流里面读取，将数据缓存也是写到流里面的。流其实就是一个中间驿站，那么，流到文件以及文件到流的操作怎么实现？就是使用的FileInptStream和FileOutputStream进行操作，这两也是输入输出流的子类，利用多态性就可以使得输入输出流的对象可以进行数据到文件的操所（本来就是数据到流或者流到数据，文件类是文件到流和流到文件）；这个流其实是被装饰过了。IO里面体现了很多的设计模式，多态性是最显而易见的。 FileInputStream,就是将文件读取到流里面；之后我们如果想要得到文件里面的数据的话，就直接利用它这个类里面提供的方法就可以将数据写到指定的内容里面，inputstream就是写到字节数组里面；同理，我们的ByteArrayIputStream其实就是将数据读取到流里面，数据是”字节数组”类型，其实这个和File是一样的，XxxInputStream里面的Xxx前面就是数据类型。同理，ByteArrayOutputStream其实就是将数据写到流里面的对象。使用它提供的方法将需要写到字节数组的数据使用write(“需要的数据”.getBytes()); 从File和ByteArray这两个类其实就知道IO的设计模式了，就是将某个形式的数据读取或者写入到流里面，File的话就是将数据从文件里面读取写到流里面或者将数据从流里面写到文件，字节数组也一样。 我们其实还有一个类需要掌握，那就是InputStreamReader / OutputStreamWriter ,这个类支持将字节流转换成字符流。所以我们可以很简单的解决一些中文乱码的问题，一般来说，将字节读取后转换成字符会出现乱码，或者是受到字节数组的大小的限制，但是字符流的读取是没有这两个问题的，所以，当需要将我们的字节流读取变成我们的字符流的时候，最好就是使用我们的这个中间的类进行一下包装，使得我们的读取和存储没有乱码的问题。具体大代码在下面的例子里面就可以很好的体现出来了: 例子代码： package bufferReader; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; public class SystemTest { public static void main(String[] args) throws IOException { SystemTest st=new SystemTest(); st.getByGood(); } public void getByByte() throws IOException{ InputStream in=System.in;//从键盘读取数据输入 int temp=0; byte b[]=new byte[1024]; System.out.println(&quot;请输入内容！&quot;); while((temp=in.read(b))!=-1){ System.out.println(new String(b,0,temp)); } //次方法有缺陷，字节数组大小的限制以及中文乱码的限制（中文乱码是当字节数组是奇数的时候只读取一般的中文 ） } public void getByOther() throws IOException{ InputStream in=System.in;//从键盘读取数据输入 StringBuffer sb=new StringBuffer(); int temp=0; System.out.println(&quot;请输入内容！&quot;); while((temp=in.read())!=-1){ //0-255其实包括了我们的字母和所有的符号？所有可以将数字和字母或者符号进行等价 char c=(char)temp; if(c==&apos;\n&apos;){ break; } sb.append(c); } System.out.print(sb); //这个方法的缺陷就是中文输入会造成乱码。原因就是这个只能每次读取一个字节，也就inputstream这类本身方法的缺陷。 } public void getByGood() throws IOException{ BufferedReader buf=new BufferedReader(new InputStreamReader(System.in)); System.out.println(&quot;请输入内容：&quot;); System.out.println(buf.readLine()); //这个方法输入没有限制，没有中文乱码的问题。 //对于InputStream来说，其read要么受到字节数组大小的影响，要么每次只能读取一个字节，很是不方便.BufferedReader一次将数据直接读取到缓冲区，解决了意以上问题 } } 由这个Scanner的构造方法我们知道，这个工具很是强大，它可以直接扫面很多的文件类型，IO的操作基本都包括了。它简直就是一个神器，可以省了我们直接使用IO操作的很多麻烦]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Iterator接口的使用]]></title>
      <url>%2F2017%2F04%2F25%2FIterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%B2%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[迭代器（Iterator） 对 collection 进行迭代的迭代器。 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。 Java中的Iterator功能比较简单，并且只能单向移动： (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。 (2) 使用next()获得序列中的下一个元素。 (3) 使用hasNext()检查序列中是否还有元素。 (4) 使用remove()将迭代器新返回的元素删除。 Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。这个是一个轻量级的对象，它可以对connection类集进行单项移动迭代，达到遍历的效果，同时还能对某个元素进行删除。但是在实际中很少调用这个删除方法，一般是用来对类集进行遍历的，而且，注意不可以在迭代的时候，进行类集里面的操作，也就是调用List或Set的remove()方法，否则会出现错误！！也就是说在使用迭代器的时候只能使用iterator自己的remove方法。 Listiterator由于Iterator是单向的遍历，考虑到实际情况，我们还有一个ListIterator接口，这个接口可以实现双向输出，也就是多了hasPrevious()和previous() 这两个主要的由后向前移动的函数，打动双向遍历的效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Map接口的使用]]></title>
      <url>%2F2017%2F04%2F24%2FMap%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[Map知识点Map简介将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。此接口取代 Dictionary 类，后者完全是一个抽象类，而不是一个接口。Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。将键值对放到Map里面的工作是由Map.Entry这个接口进行的，它是一个静态接口，在这个接口里面只有五个方法，分别是 boolean equals(Object o) 比较指定对象与此项的相等性。 K getKey() 返回与此项对应的键。 V getValue() 返回与此项对应的值。 int hashCode() 返回此映射项的哈希码值。 V setValue(V value) 用指定的值替换与此项对应的值（可选操作）。 每次增加键值对的时候，都会调用这五个方法。由于不能有相同的键值，所有要判断键值是否相等，同时，一个键只能映射一个值。 Map的实现之HashMapHashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。 我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，它的工作原理就是这样：每次初始化一个HashMap的时候，就会初始化一个table数组，这个数组的元素都是entry节点，每个数组都是一个链表的索引。 首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。所以数组的索引其实就是一个链表的表头，通过表头我们可以遍历该链表的所有数据。Entry是HashMap的一个内部类，使用它的作用其实就是建立一个链表，每一个Entry都存了下一个节点的对象，也就是一个一个对象里存有下一个对象，这样就可以构成我们的链表。所有，在找打数组索引后，我们按照key的值进行链表的遍历排查，如果遍历链表（null链表也可以遍历！）key不重复，则将将加入的键值对作为链表的表头，将其他的元素挂在后面就可以了。如果存在相同的key，则将value的值覆盖就可以。 一是链的产生。这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。 二、扩容问题。随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 一开始的 transient Entry[] table = (Entry[]) EMPTY_TABLE;是一个空的数组？不是，如下：这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%（len-1）获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。这样，我们可以在一个很小的数组里面，存放很多的Entry(每个Entry有key,value,next)，如果hashCode不一样，那么即使存放在同一个数组下标下面，在存放的时候，key和value是不一样的，可以顺利操作，但是如果key的hashCode一样的话，那么会存放在相同的table[index]下，这时候有，由于hashCode一样，前面我们知道，要保证一个对象的不重复，不仅需要hashCode还有equals，其实equals才是最重要的，equals相等的话，两个对象一定是一样的，但是为了提高效率，hashCode不一样的时候，两个对象一定是不一样的（后面这句话可以提高效率，所有一般先比较hashcode，hashCode一样的时候，为了确保正确才使用equals!!）,所以，即使碰撞，我们由于equals的存在，可以很简单的解决。如果真的是同一个key，则直接覆盖value,否则就是一个新的Entry的简单加入，也就是链表的数据增加而已。 public V put(K key, V value) { if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } TreeMap这个其实和我们的Set里面的TreeSet一样，自定义的类使用的话，要实现Comparable接口，注意到这一点就可以。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Set接口的使用]]></title>
      <url>%2F2017%2F04%2F23%2FSet%2F</url>
      <content type="text"><![CDATA[Set介绍HashMap和HashSet里面的键值和对象的不相等在Java的集合中，判断两个对象是否相等的规则是： 判断两个对象的hashCode是否相等 如果不相等，认为两个对象也不相等，完毕 如果相等，转入2)（这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。后面会重点讲到这个问题。） 判断两个对象用equals运算是否相等 如果不相等，认为两个对象也不相等 如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键） HashMap不允许有相等的键值，HashSet不允许有相等的对象元素。说一下hashCode和equal的区别，其实我们的底层都是hashCode进行比较的，也就是说，一个对象的equals一样的话，那么它的哈市Code是一样的， @Override public int hashCode() { // TODO Auto-generated method stub return 一个int数; } @Override public boolean equals(Object obj) { // TODO Auto-generated method stub return this==obj; } 一般来说，我们的equals一样是，那么他们的地址是一样的（这是java规定的），但是如果他们的equals不相等的话，那么他们的hashCode不确定，为什么？因为hashCode的算法决定的。例如一个类的hashCode的算法是： @Override public int hashCode() { // TODO Auto-generated method stub return this.name.hashCode()+this.password.hashCode(); } @Override public boolean equals(Object obj) { // TODO Auto-generated method stub if(obj==null){ return false; } User user=(User)obj; if(obj==this){ return true; } if(this.name.equals(user.getName())&amp;&amp;this.password.equals(user.getPassword())){ return true; } return false; } hashCode返回一个int值，当自定义的时候就可能返回一个不一样的值。如果没有被覆写的话，那就返回的是哈希算法的结果。在我们覆写的方法里面，我们要按照jdk的要求，如果覆写了equals的话，那么hashCode是一定要覆写的，而且，如果equals相等的话，那么hashCode是一定要相等的。因为两个相等的对象的hashCode是一定一样的。当你使用HashSet的时候，add的时候调用的hashCode和equals是你覆写过的方法。总结：在使用Set的时候，保证两个元素是否相等的关键就是两个方法，hashCode和equals,一般是先比较hashCode，如果不相等，则两个对象不一样，如果相等，则进行equals的比较，如果一样则两个对象是一样的（同一内存的引用）。一般使用hashCode的原因是提高hashMap的效率和性能。所以，当我们的项目有要求的时候，我们是需要自己覆写hashCode和equals方法的。 HashSet和TreeSet使用HashSet的时候，将元素放到内存的时候，是乱序放入的，也就是和你的java语句的顺序是无关的，但是使用TreeSet的时候是会自动排序的。TreeSet的使用： 类要实现Comparable接口，覆写比较的方法 int compareTo(T o) @Override public int compareTo(User o) { System.out.println(&quot;比较方法被调用！&quot;); // TODO Auto-generated method stub int x= this.name.compareTo(o.getName()); if(x==0){ return this.password.compareTo(o.getPassword()); } return x; } 先比较什么，在再比较什么可由你自己决定。一个类实现了Comparable接口后，它的set就变得有序了，就算你使用的是HashSet，也不在是乱序插入。但是不是排序的，这一点和TrssSet还是有区别的。 TreeSet这个接口是谁TreeSet的子接口，使用SortedSet接口的子类是可以排序的子类，SortedSet的基本用法和TreeSet是一样的，在本章的例子里面我们主要就是熟悉一下其获取第一个和最后一个以及在两个在指定的元素之间的所有元素这三个方法。在前面我们知道，实现Set接口的类是不能有重复的元素存在的，这个的保证就是hashCode和equals方法，但是，set接口无法实现排序（既然所有元素不相等，我们可以考虑加入排序操作），所有就有了TreeSet接口，实现这个接口的时候记得覆写我们的comparableTo方法实现自己的排序规则。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[序列化]]></title>
      <url>%2F2017%2F03%2F30%2F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[IO编码问题 使用utf-8编码的说可以被gbk成功解码显示，没有乱码 使用iso8859-1编码的数据无法被gbk正确解码，出现中文乱码。对象的序列化 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。 把Java对象转换为字节序列的过程称为对象的序列化。 把字节序列恢复为Java对象的过程称为对象的反序列化。 对象的序列化主要有两种用途： 1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 2） 在网络上传送对象的字节序列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh之值栈]]></title>
      <url>%2F2017%2F03%2F29%2Fssh%E6%95%B4%E5%90%88%E4%B9%8B%E9%A1%B5%E9%9D%A2%EF%BC%9A%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[1.pageContext.request.contextPath获得的是项目的名称。比如： /ssh_manager 前面有一个斜杠。 2.ssh的思想就是访问的是我们的action而不是直接的jsp，这样的话，你要学会在一个Action里面去处理很多的jsp请求。 3.模型驱动的值会默认放在值栈里面，而且，我们在一个Action里面有很多个方法的时候，每次访问一个方法的时候，就实例化一个Action,而且每个Action里面的值栈都是不一样的。 4.在jsp使用模型驱动里面的数据：1&lt;s:property value=&quot;model.属性&quot;&gt; 5.对值栈的理解：值栈就是一个栈，也就是数值是从顶到底读取的，不过它会自动帮我们去匹配，输出的是第一个匹配到的数据。==如果我们把一个对象放到值栈里面==：例如PageBean;123456789101112131415161718192021222324252627282930313233343536public class PageBean &lt;T&gt;&#123;//分页显示这个·相当于List&lt;E&gt; private int currPage;//当前页 private int pageSize;//每页显示 private int totalPage;//总页数 private int rowPage;//总记录 private List&lt;T&gt;list;//当前页面的数据 public int getCurrPage() &#123; return currPage; &#125; public void setCurrPage(int currPage) &#123; this.currPage = currPage; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public int getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public int getRowPage() &#123; return rowPage; &#125; public void setRowPage(int rowPage) &#123; this.rowPage = rowPage; &#125; public List&lt;T&gt; getList() &#123; return list; &#125; public void setList(List&lt;T&gt; list) &#123;//这个是从数据库得到的，上面的其他数据是提供给数据库的。 this.list = list; &#125; 之后在页面我们就可以使用一整个pageBean,包括里面的各个属性，而且可以直接使用属性的名字来获得该属性的值，它会在底层自动帮我们查找。而且还支持对list属性的iterator迭代。他会自动的将pageBean里面的list属性直接的给到我们的 注意：这个value要写对，要和pageBean里面的属性值一样。 2.对于页面单纯跳转到显示页面的做法：首先，对任何的jsp页面的请求，我们都是将请求给到我们的action进行处理的，这个的好处就是防止直接访问到我们的jsp，还有一个醉最大的好处就是，我们跳转到的页面需要的数据可以先在我们的Action里面直接准备好，这样jsp页面对java代码的耦合性就达到最低了。例如在员工系统里面，我们需要修改一个员工的信息，这时候我们的修改页面需要的数据有，该员工的所有原来的信息，这就要将该对象放到模型驱动里面，或者是值栈里面，接着，如果修改页面还需要所有部门以供选择的话，还要将所有部门的集合放到值栈里，这样在页面进行跳转后，我们的jsp页面就可以很直接的就得到我们在action里面为准备的所有的数据。直接利用==ognl==表达式就可以得到。 3.对于jsp页面请求的时候数据接收时发生错误会报出很多错误，其中就有一个是无法找到action,其实不是找不到，是它在为Action进行数据的封装的时候出现了错误而无法直接实例化我们得Action.特别是在使用了list集合的jsp页面，好像数据填写不完全就会报错，这个我也不是很懂。我的想法就是这个可以直接交给到我们的脚本进行判断，如果填写不符合规则就提交不了。很简单，不要后台进行处理。你还可以直接利用我们的ajax技术进行及时的提醒等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO流的复习--文件的写入]]></title>
      <url>%2F2017%2F03%2F29%2FIO%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5%2F</url>
      <content type="text"><![CDATA[字节流的形式写入我们将需要写入的数据先得到其字节流数组后直接写入到我们的文件里面具体代码如下： //1.将数据写到我们的指定文件； OutputStream ot=new FileOutputStream(&quot;e:\\myeclipse 2015 workplace\\testfile\\test2.txt&quot;); ot.write(&quot;你好&quot;.getBytes()); 字符流的形式写入其实将文本或者其他写到文件的最好的就是使用我们的BufferedReader,使用这个BufferedReader还有一些需要注意的事情：具体代码如下： //2.字符流的形式直接写入 BufferedWriter br=new BufferedWriter(new FileWriter(&quot;e:\\myeclipse 2015 workplace\\testfile\\test3.txt&quot;)); br.write(&quot;你好&quot;); br.flush(); br.close(); 说一下注意事项：使用BufferedWriter 将内容写入文件，先开始少了wriite.flush()这句，发现无法写入内容。查资料后发现，原来BufferedWriter是缓冲输入流，意思是当你调用BufferedWriter的write方法时候。数据是先写入到缓冲区里，并没有直接写入到目的文件里。你必须调用BufferedWriter的flush()方法。这个方法会刷新一下该缓冲流，也就是会把数据写入到目的文件里。必须有这句的样子，实践中如果没有writer.flush(); 仅有writer.close();，会报异常。 所有的文件的写入，在没有该文件的时候会自动创建该文件，文件存在的话直接覆盖该文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于使用hexo搭建自己的博客]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo%2F</url>
      <content type="text"><![CDATA[环境的搭建- 1.介绍：我们使用的这个博客生成器，其实是一个台湾大学生创建的，它的环境是主流的node.js,因此，我们需要先配置好node.js环境，node.js的安装自己百度就可以很快搞定，它有windows,linux，mac都有。使用这个hexo我们可以很简单的创建一个很炫酷的个人博客哦。 - 2.安装hexo:安装好node.js后，我们需要安装hexo,安装的指令是，在我们的命令窗口，输入： npm install hexo -g这个表示在这个环境里面安装好博客生成器。之后我们就可以使用简单的命令生成自己的博客了。 - 3.开始：首先，在一个文件夹里面，按住shift 后右键，选择在此打开cmd,输入：hexo init,这样就生成了一个简单的博客需要的所有配置文件，再使用hexo g这样就生成了一个博客，使用hexo s启动博客，在自己打的浏览器输入cmd里面的地址可以看到一个 HEXO 的博客页面。 修改自己的博客 1.搭建好自己的博客后，需要修改很多的内容来进行自己的优化，主要是修改两个配置文件，一个是站目录下面的配置文件，另外一个是主题目录下的配置文件。这两个文件的配置可以使得你的hexo主题改变很大。 2.站目录下的配置文件主要是配置我们项目发布到github的参数，在这个配置文件的最下面配置，注意我们使用的hexo版本，我使用的是3.0好像，这个版本在上传文件的时候，下面的代码： deploy: type: git repository: https://github.com/kingfou/kingfou.github.io.git branch: master 2.配置好后，将文件上传到我们的github上面，首先你要自己先在github上面注册和申请好自己的仓库，很简单的。自己百度。之后的操作就是：hexo d如果报错，请用github的 shell命令器cmd到自己的博客站目录下面 hexo d。如果提醒没有初始化什么的，直接git init,之后就可以了。 3.关于自己对主题的一些修改，这些都得在主题的那个配置文件里面自己一个一个慢慢设置，我使用的是next这款主题，十分炫酷。直接上next的官网就可以看到怎么修改一些内容。关于next主题1.介绍next我看过了hexo官方的很多主题，但是不太喜欢，最后遇到next，我觉得这个主题真的很好，虽然很多人在用，如果我的css够厉害的话，我们完全可以自己修改出很厉害的风格。所有，下面说说对这个主题的配置文件的一些修改吧。2.添加我们的本地搜索这个其实很简单，首先，修改站目录下的配置文件，将下面的代码写道配置文件的任何地方都可以：123456#站内搜索：search: path: search.xml field: post format: html limit: 10000 之后在主题的配置文件下面，找到那个local_search:123# Local searchlocal_search: enable: true 将enable 改为true即可。不过，我们还要做一件事，那就是在站目录下面加入一个插件，具体代码如下：1npm install hexo-generator-search --save 3.添加评论我们选择的是gengtie，也就是网易的云跟帖，这个真的不错，在next5.0以上的版本立面，我们只需要在主题得配置文件立面写上跟帖得idKEY就可以直接使用，也就是，一句代码得事。12 Gentie productKeygentie_productKey: 7e78cfd0046048efa69b351937e41a36 4.添加访问统计这里我使用得就是不蒜子这个第三方插件，配饰也很简单。就在主题文件立面修改就行。修改后如下。123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站访问游客 site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: 本文总阅读量 page_pv_footer: 次 设置全文阅读在主题配置文件立面写上：123auto_excerpt: enable: true length: 150 这样就可以使用了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO流的复习--文件的读取]]></title>
      <url>%2F2017%2F03%2F29%2FIO%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%2F</url>
      <content type="text"><![CDATA[1.使用BufferedReader对文件进行读取使用这个类的好处是可以调用它的一个读取一行的方法。ReadLine();而且BufferedReader本来就是用来读取字符流的，这样可以直接避免中文乱码的出现。具体的代码如下: BufferedReader buf=new BufferedReader(new FileReader(&quot;e:\\myeclipse 2015 workplace\\testfile\\test1.txt&quot;)); //读取的是字符？ System.out.println(&quot;读取的内容如下&quot;); String str=&quot;&quot;; while(true){ str=buf.readLine(); if(str==null){ break; } System.out.println(str); } 使用FileInputStream读取文件这个其实是按照字节流的方式读取文件？我们的一个中文是两个字节，所以我们读取该文件的时候，要保证将该文件读取完全，需要知道字节数？ InputStream in=new FileInputStream(&quot;e:\\myeclipse 2015 workplace\\testfile\\test1.txt&quot;); byte b[]=new byte[1024]; in.read(b,0,2); System.out.println(new String(b)); 说一说装饰：（体验一下什么是装饰模式） 在这段代码中，沃我们只读取一个中文。注意到两个类在实例化的时候的区别，在第一个例子里面，我们使用的是一个中间的类:BufferedReader,它实现Reader(字符流的接口),在对它实例化的时候，我们使用的是 BufferedReader buf=new BufferedReader(new FileReader(&quot;filePath&quot;));这个FileReader也是 实现了Reader接口的，所以这个buf其实就是起到了一个装饰的作用，也就是说，一个老大有两个小弟：BufferedReader和FileReader;但是他们的功能不一样，例如BufferedReader不能直接读取文件，FileReader不能读取文件的一行。但是我们想要读取文件的一行，所有得赋予BUfferedReader读取文件的功能，这个就是装饰。也可以这样说，BufferedReader装饰了FileReader，使得它可以读取文件的一行。 分析这两种方式的区别一个是以字符流的方式读取的，速度快，简单便捷；另外一个是以字节流的方式读取的，其方法read(byte b[])是将数据按照字节流的方式读到我们的字节数组b里面的。这种方式最好用来读取我们的图片。其实也可以直接使用FileReader的文件读取方法来完成对文件的读取，它是将字符读取到我们的字符数组；（注意是字节读取到字节数组，字符读取到字符数组。） Reader r=new FileReader(&quot;e:\\myeclipse 2015 workplace\\testfile\\test1.txt&quot;); char []c=new char[8]; r.read(c); System.out.println(new String(c)); 将数据读取到字符数组里面和字节数组里一样很麻烦，所有我们采用的BufferedReader对我们的FileReader进行装饰。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh总结1]]></title>
      <url>%2F2017%2F03%2F10%2Fssh%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[1.理解：我们在项目里，本来是有三个配置文件要写的， 1.struts.xml：负责对action和访问的Action进行匹配，并且会根据Action的返回结果进行页面的跳转操作，在struts.xml里面，要注意的就是跳转的形式，result type的取值又很多，比如我们的json形式就是加入json插件又的一种同时，在struts.xml里面，我们还要注意的是action对Action里面方法的访问的写法；struts里面也定义了很多的拦截器，如果我们使用了自定义的拦截器的话，那么在访问该Action的时候，我们需要手动的去调用默认的拦截器栈。还有就是我们的常量的配置，可以起到很多的作用，比如自定义的错误消息的提醒，启用一些其他属性。这个可以查我们的default-struts这个配置文件，里面又所有的常量。 2.applicationContext.xml：1.这个配置文件是我们spring里面的配置文件，它的作用就是进行bean的注入，EJB,企业级java bean ，也就是说，将对bean的实例化等操作直接在配置文件里面完成。在ssh里面，我们也是直接的使用这个bean.xml来对我们的struts.xml和beans.xml进行整合的；1.对struts进行整合，就是将Action类的实例化的工作直接交给到我们的beans.xml，这时候在配置我们的action的时候，class=”id”,这个id就是我们在beans..xml里面的id,2.对hibernate进行整合：我们会将hibernate配置文件的内容直接都在这个beans.xml里面进行配置，这时候，我们的Dao类需要继承一个类，HibernateDaoSupport类，这个类继承后需要我们在beans.xml里面进行一些属性的配置，毕竟是继承来的，有很多的属性是需要配置的。 1.配置数据源，数据源可以写在一个新的peoperties文件里，我们在beans.xml里面直接读取赋值就可以，beans.xml读取其他的配置文件时候，要加入一个常量的配置： &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; 这句话表示我们会加载src目录下面的配置文件，之后对数据源进行配置，内容如下： ` 注意这个bean的包所在；就是我们引进来c3p0的jar包； 2.配置sessionFactory会话工厂：也就是对数据库的最高级操作，这个是一个重量级的 对象，一般我们只会实例化一次， 之后，它就接管数据库的链接管理， 使用数据库的时候，直接调用它提供的openSession()就可以得到一次岁数据库的操作。。 注意这个bean里需要配置以下三个属性值： 1.dataSource: 2.hibernateProperties:这个文件主要配饰hibernate对于的数据库类型和sql语句的一些显示，表的自动创建等： 由于这些属性是本来就存在的，因此我们属于的是properties文件的属性的注入形式： &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;/props&gt; 3.mappingResources:这个配置的是我们的domain类的关系映射文件，由于关系映射文件有多个， 因此需要用&lt;list&gt;标签列出来： &lt;list&gt; &lt;value&gt;com/imooc/domain/Product.hbm.xml&lt;/value&gt; ..... &lt;/list&gt; 12 接下来我们讲一下，为什么在继承了HibernateDaoSupport这个类的时候，我们就要去配置这个sesionFactory这个类：首先查看我们的HibernateDaoSupport的源码，我们知道，在这个源码里，它提供了一个HibernateTemplate对象，这个就是我们在dao进行hibernate操作的根本。但是这个对象的实例化，也就是创建,需要传入一个sessionFactory,它里面有这个sessionFactory的setter方法了，我们可以在beans.xml里面直接注入就行。整个流程：1.使用HibernateDaoSupport需要配置一个bean-sessionFactory,这个bean在hibernate核心包里面，这个类里面我们要配置三个属性：数据源，hibernateProperties,mappingResource这三个属性，其中，由于hibetrnateProperties的属性是存在的，采用的是props标签，而mappingResource里的关系映射文件是用list标签来写的。 3.hibernate.cfg.xml：这个文件虽然被beans.xml整合了，但是独立的话，它的作用就是配置数据源，配置数据库的类型，配置数据库sql语言，管理关系映射文件。之后在类里通过加载这个配置文就可以得到一个sessionFactory了。12 总结：总的来说，我们最好的整合方法就是将所有的类的实例化，属性的注入等工作交给beans.xml文件，这时候，我们的hibernate的配置等全部是在这个文件立面完成的，也就是说没有了hibernate.cfg.xml文件，而action的关系映射就直接在struts.xml立面完成。使用struts和spring之前，在web.xml立面，也有很重要的配置需要记住，那就是：1.struts核心过滤器的配置： &lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2.spring 监听器的配置： &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 说说这个ContextLoaderListener的作用：它的作用就是在web启动的时候 自动的去加载我们的beans.xml配置文件，不过在默认的情况下下， 他会去加载WEB-INFO下面的applicationContext.xml这个配置文件 ，因此，如果我们的配置文件在src目录下的话，我们就需要制定加载配置文件的所在路径，需要使用到下面的标签： &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; ```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2实现ajax]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E5%AE%9E%E7%8E%B0Ajax%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[1.Ajax是什么，怎么实现？ 使用JQuery的方法实现 使用html的方法实现 JSON:在JQuery里面，我们提供了两种实现的方法 load(URL,data,callback);其url是请求的url，也就是要访问的服务的地址，data是请求的参数，可以为空，也可以带请求参数，最后的是一个回调函数，请求的数据直接放在回调函数里面。回调函数的构造类型如下：1234可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：responseTxt - 包含调用成功时的结果内容statusTXT - 包含调用的状态xhr - 包含 XMLHttpRequest 对象 2.$.get(URL,callback); 这是使用jquery的方法写的ajax,回调函数的使用如下： 12function(data,status)第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。 $.post(URL,data,callback);这个的用法和get是一样的，只是它可以带有自己的请求参数，也就是将页面的某个属性直接赋值后请求，例如直接请求id是多少的某个属性。 2.使用我们的struts实现ajax的时候，要手动导入另外的两个包。一个是struts提供的JSON插件支持包，另外一个就是JSON的包，它提供将对象直接字符串化的方法，这样才可以直接在action里面放回字符串的请求结果。此外，我们的struts配置内容如下：1234567&lt;package name=&quot;root1&quot; namespace=&quot;/&quot; extends=&quot;json-default&quot; &gt;&lt;!-- 实现AJAX的Action配置 --&gt; &lt;action name=&quot;ajax&quot; class=&quot;com.imook.action.AjaxAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;json&quot;&gt;&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 这里的json-default包其实就是我们的struts-josn的插件。这个是请求的数据是对象的时候； 3.请求的是集合的时候。其实原理是一样的，就是请求后在html页面得到的那个数据其实四一个集合的字符串，我们可以先得到该对象，之后进行遍历就可以得到我们想过的数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Action三种获取表单的模式]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%20Action%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[1.我们写的Action当继承了ActionSupport的时候，它会自动获取提交到该action的请求里面的表单数据，会缓存起来，如何获取呢？它的底层已经利用架构或者其他的配置文件，doj4等技术，只要我们的Action类里的属性名和表单的name标签的名字一样的时候，同时在Action里的属性有setter和getter的时候会自动获取，这个和我们的Spring的依赖注入很类似。2.通过一个implements ModelDriven接口来实例化封装的表单的数据。 3.详细解释： 域驱动：就是将表单的属性名称在action里面按照依赖注入的形式填充完成，这时候的成功因素就是Action里面的属性要和表单的name属性一致 属性驱动，所谓的属性驱动就是先将表单的提交信息封装好，成一个pojo，我们在action里的属性现在就是pojo,设置好pojo的setter和getter就行，在jsp页面写的就是pojo实例的属性。例如： `private User user;setter;getter; form;//表单形式name=”user.name”;name=”user.password” POJO://POJO类 User{ name; password; }` 表单的user会自动去寻找Action对应的属性user的，就是表单逆向寻找Action的属性。 3.模型驱动，modelDriven接口的实现，我们一开始就实现接口:`implements ModelDriven{private User user; Uer getModel(){//覆写方法if(user==null){ user=new User(); } }}`//这样就是自动的驱动我们的模型完成数据填充。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2文件上传]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[1.文件上传是在表单中完成的。表单提交到一个action里面，在action里面，我们开始对提交的文件进行操作。2.两个重要的属性的setter和getter，我们在html页面写的file 标签的名字要和Action里的名字是对应的。比如 123&lt;form method=&quot;post&quot; action=&quot;url&quot; enctype=&quot;multipart/form-data&quot;&lt;input type=&quot;file&quot; name=&quot;newname&quot;/&gt;&lt;/form&gt; 这样的话，我们可以得到上传文件的类型和名称，其中属性： 12- 1.newnameFileName(html的名字+FileName) - 2.newnameContentType(html的名字+ContentType) 这样就可以直接获取上传文件的名称和类型。 2.Action代码：1234 private File photo;private String photoFileName;private String photoContentType; html代码：1234&lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 文件上传：&lt;input type=&quot;file&quot; name=&quot;photo&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt;&lt;/form&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[strut2拦截器]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%20%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
      <content type="text"><![CDATA[1.拦截器和过滤器本质上是一一样的。只是拦截器是一个一个按照顺序执行的，而过滤器则是按照配匹配的方式执行的。 2.struts2的架构实现就是依赖大量的拦截器来实现的。例如prepare ，fileupload,什么的，它会自动的将表单的数据直接封装成我们的Action类，我们就可以直接在Action里面使用了，这底层的机制就是依赖注入。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh之配置文件理解]]></title>
      <url>%2F2017%2F03%2F02%2Fssh%E4%B9%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[配置文件的理解 1.struts.xml：负责对action和访问的Action进行匹配，并且会根据Action的返回结果进行页面的跳转操作，在struts.xml里面，要注意的就是跳转的形式，result type的取值又很多，比如我们的json形式就是加入json插件又的一种同时，在struts.xml里面，我们还要注意的是action对Action里面方法的访问的写法；struts里面也定义了很多的拦截器，如果我们使用了自定义的拦截器的话，那么在访问该Action的时候，我们需要手动的去调用默认的拦截器栈。还有就是我们的常量的配置，可以起到很多的作用，比如自定义的错误消息的提醒，启用一些其他属性。这个可以查我们的default-struts这个配置文件，里面又所有的常量。 2.applicationContext.xml：1.这个配置文件是我们spring里面的配置文件，它的作用就是进行bean的注入，EJB,企业级java bean ，也就是说，将对bean的实例化等操作直接在配置文件里面完成。在ssh里面，我们也是直接的使用这个bean.xml来对我们的struts.xml和beans.xml进行整合的；1.对struts进行整合，就是将Action类的实例化的工作直接交给到我们的beans.xml，这时候在配置我们的action的时候，class=”id”,这个id就是我们在beans..xml里面的id,2.对hibernate进行整合：我们会将hibernate配置文件的内容直接都在这个beans.xml里面进行配置，这时候，我们的Dao类需要继承一个类，HibernateDaoSupport类，这个类继承后需要我们在beans.xml里面进行一些属性的配置，毕竟是继承来的，有很多的属性是需要配置的。 1.配置数据源，数据源可以写在一个新的peoperties文件里，我们在beans.xml里面直接读取赋值就可以，beans.xml读取其他的配置文件时候，要加入一个常量的配置： &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;这句话表示我们会加载src目录下面的配置文件，之后对数据源进行配置，内容如下：&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; ` &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; `]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义错误消息]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A02%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E6%B6%88%E6%81%AF%EF%BC%89%2F</url>
      <content type="text"><![CDATA[1.ServletActionContext.getServletContext().getRealPath(“/“)可以直接获得当前项目的真实路径。 一个result代表了一个可能的输出。当Action类的方法执行完成时，它返回一个字符串类型的结果码，框架根据这个结果码选择对应的result，向用户输出。在com.opensymphony.xwork2.Action接口中定义了一组标准的结果代码，可供开发人员使用，当然了只有我们的action继承ActionSupport 这个类才可以使用下面的结果代码，如下所示： 12345678public interface Action&#123; public static final String SUCCESS = “success”; public static final String NONE = “none”; public static final String ERROR = “error”; public static final String INPUT = “input”; public static final String LOGIN = “login”;&#125; 其中 Struts2应用在运行过程中若发现addFieldError()中有信息或者类型转换失败或着输入校验失败等情况那么它会自动跳转到name为input的1&lt;result/&gt; ，然后转到INPUT所对应的页面若JSP页面中表单是用普通编写的，发生错误而返回该页面时，则原数据将消失若JSP页面中表单是用编写的，发生错误而返回该页面时，则原数据仍存在若没有提供name值为input的，那么发生错误时，将直接在浏览器中提示404错误 除了这些预定义的结果码外，开发人员也可以定义其它的结果码来满足自身应用程序的需要。 3.由上面的笔记我们可以知道，默认的返回字符串是success,input,error,none,login这些。。。 3.修改默认的消息返回配置： 4.在我们的struts的核心包下面有一个配置文件default-properties,这个配置文件是无法直接修改的，但是里面是我们可以配置的所有的常量的集合，我们在struts,xml文件里面配置的常量其实在这里是全部可以直接找到的。在这下面还有很多的配置文件，比如struts-message这个配置文件，里面就有当信息出错是加载的常量属性。struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} “{1}” “{2}” {3} 这一段是在类型不允许的时候显示的，其中，0,1,2,3是文件的详细情况。文件名和文件类型什么的。我们写了一个配置文件赋值给一个常量，1&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;msg&quot;&gt;&lt;/constant&gt; 这个配置文件完成的时候，他会把struts-message里面的1struts.messages.error.content.type.not.allowed=Content-Type not allowed: &#123;0&#125; &quot;&#123;1&#125;&quot; &quot;&#123;2&#125;&quot; &#123;3&#125; 直接换成msg.properties下面的代码1struts.messages.error.content.type.not.allowed=\u60A8\u4E0A\u4F20\u7684\u6587\u4EF6\&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;\u7C7B\u578B\u6709\u8BEF 这一切，其实就是将一个常量直接等于一个配置文件，配置文件自己再为常量赋值？？？？ 5.每次使用自己写的拦截器的时候，一定要自己再手动加默认的拦截器栈。 6.文件上传的时候，对文件的格式，文件的大小一起其他的限制，我们可以直接在fileUpload这个拦截器里面直接配置好就行，必要的时候，可以自己配置文件不符合限制的时候的提示消息，这个消息的常量在我们的struts-messgae里面找到对应的属性，将此属性直接在自己写的配置文件里赋给新的提示消息值，之后将此配置文件赋值给对应的常量。 具体流程： 121.找到struts-message文件里面对应的属性，例如文件类型错误：struts.messages.error.content.type.not.allowed 122.将此属性copy到自己的配置文件里重新赋值：struts.messages.error.content.type.not.allowed=？？？？？ 12343.在我们的struts.xml配置文件里配置常量：&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;msg&quot;&gt;&lt;/constant&gt;这个msg就是我们自己的消息提示配置文件，我们将这个配置文件赋值给到这个常量就行。 14.这样当文件不符合的时候就会提示我们自定义的消息了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文件上传的限制]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[1.限制上传的文件大小可以直接在我们的fileUpload拦截器里直接配置好属性就可以fileUpload的属性如下：12345&lt;interceptor-ref=&quot;fileUpload&quot;&gt; &lt;param name=&quot;maximumSize&quot;&gt; 1024*1024; &lt;/param&gt;&lt;/interceptor&gt; 2.由于文件上传的时候，自己也会有一个默认的最大值，那个就是2M，这个时候，我们还是要修改一个常量，那就是struts.multipart.maxSize1&lt;constant name=&quot;struts.multipart.maxSize&quot; value=&quot;5242880&quot;&gt;&lt;/constant&gt; 3.文件下载：12345678910contentType内容类型，和互联网MIME标准中的规定类型一致，例如text/plain代表纯文本，text/xml表示XML，image/gif代表GIF图片，image/jpeg代表JPG图片inputName下载文件的来源流，对应着action类中某个类型为Inputstream的属性名，例如取值为inputStream的属性需要编写getInputStream()方法contentDisposition文件下载的处理方式，包括内联(inline)和附件(attachment)两种方式，而附件方式会弹出文件保存对话框，否则浏览器会尝试直接显示文件。取值为：attachment;filename=&quot;struts2.txt&quot;，表示文件下载的时候保存的名字应为struts2.txt。如果直接写filename=&quot;struts2.txt&quot;，那么默认情况是代表inline，浏览器会尝试自动打开它，等价于这样的写法：inline; filename=&quot;struts2.txt&quot;bufferSize下载缓冲区的大小。在这里面，contentType属性和contentDisposition分别对应着HTTP响应中的头Content-Type和Content-disposition头。 4.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HQL语句]]></title>
      <url>%2F2017%2F02%2F22%2FHQL%20%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[复习hibernate 的配置文件的写法： 回忆配置文件的配置顺序：数据库部分：在这一部分，我们的配置顺序就是按照前面的图进行配置，主要的参数有1234567891011121314151617181920&lt;!--配置数据库--&gt;connection.driver_classconnection.urlconnection=usernameconnection=userpassword&lt;!-- 配置使用的是什么数据库 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 配置sql语句的一些属性 --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 读取配置好的表格的属性 --&gt; &lt;mapping resource=&quot;com/imooc/domain/User.hbm.xml&quot;/&gt; &lt;mapping resource=&quot;com/imooc/domain/Goods.hbm.xml&quot;/&gt; &lt;mapping resource=&quot;com/imooc/domain/Paper.hbm.xml&quot;/&gt; &lt;!--在上面的sql语句配置中，show_sql表示输出实现时候的sql语句，hbm2ddl.auto则表示的是自动按照映射文件生成表格。--&gt; 加载配置文件：配置文件默认是在src目录下面的，如果不在根目录下面，则加载的时候要写全路径，也就是在src下面的==全路径==。 ######关系映射文件里面的one-to-many 和many-to-one: 首先确定好是一对多还是多对一，多的那个需要有外键，外键的参数就是那个一的主键。也就是==多==的这个里面的外键其实是==一==那个的主键。这时候，在创建表格的时候，我们这样考虑，其实多这个表的创建是需要一这个表的主键作为外键的。因此，我们需要注意顺序，就是先写的资源是==一==的那个，之后再写多的那个。这就可以解释我们在配置==一==那个表的关系映射文件的时候，为什么在配置set的时候有那么多的参数要配置，为的就是可顺利创建==多==的那个表格。 123456&lt;set name=&quot;domain里面的属性名称&quot;&gt;&lt;key column=&quot;user_id&quot;&gt;&lt;!--作为别人的外键--&gt;&lt;one-many class=&quot;对应的类&quot;/&gt;&lt;/set&gt;其实一个类对应一个表格，因此它可以寻找到该表格的。可以这样想：其实是按照你给到的类，对应到表格，在对应到表格的具体栏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2拦截器]]></title>
      <url>%2F2017%2F02%2F20%2Fstruts2%20%E5%81%9A%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%2F</url>
      <content type="text"><![CDATA[1.由于struts2的拦截器只对我们的action请求起到拦截作用，因此，我们完全可以直接访问jsp页面而不被拦截，但是如果我们的jsp是放在WEB-INF下面的话，我们则可以解决此问题2.拦截器拦截的原理是，判断session里是否已经有了登录信息，有则放行，invocation.invocate();这个方法表示比可以继续访问我们的action了，这个action是在struts里的配置，它是先找到struts.xml配置，再找到对象的Action的，当然，Action也可能不存在，直接做页面的跳转工作就行。3.拦截器的使用注意：使用自定义的拦截器的时候，默认的拦截器是关闭的。这是在访问这个action的时候发生的，也就是当你在访问此action的时候，如果你使用了自定义拦截器的话，那么在智执行这个action访问的时候只会调用你定义的拦截器，默认的拦截器是关闭的，除非你在此之前显式调用。4.由于默认拦截器比较多，一般我们自己应以一个拦截器栈，将默认拦截器栈先放进去，再放我们的自定义拦截器就形成我们自己的拦截器栈。 5.详细说明见链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[欢迎来到我的博客]]></title>
      <url>%2F2017%2F02%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[欢迎来到我的个人博客，在这里你可以看到我日常学习的笔记还有生活的点点滴滴，通过这个博客你可以认识到我，了解到我。希望大家一起互相学习，共同进步。 博客内容日记123我的博客中，有日志这个分类。我会将我日常的生活的点点滴滴直接写在这里，将自己的成才历程和大家一起分享哦。 笔记1笔记的话，我会在学习的过程中，将遇到的问题，解决方法，解决方法后的感受等都记录在我的博客里面。我觉得写笔记是一个很好的习惯，说不定你遇到的问题刚好我就解决了呢？这样效率就提高了。还有，记笔记是一个不断的记录自己成长的过程。所以，每一份笔记我们都要好好的对待。 More info: Server 个人情况12这个主要就是介绍我自己而已。。。。希望大家能喜欢我的博客。 More info: Generating 随笔12就记录自己平时的心情咯，自己的一些想法什么的。文艺的，小清新的什么都可以找到的到。]]></content>
    </entry>

    
  
  
</search>
