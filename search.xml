<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[欢迎来到我的博客]]></title>
      <url>%2F2017%2F03%2F30%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速开始Create a new post12345678```More info: [Writing](https://hexo.io/docs/writing.html)### 启动服务的名称``` bash$ hexo server More info: Server 进行编辑1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F29%2FHello-World-0%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh之值栈]]></title>
      <url>%2F2017%2F03%2F29%2Fssh%E6%95%B4%E5%90%88%E4%B9%8B%E9%A1%B5%E9%9D%A2%EF%BC%9A%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[1.pageContext.request.contextPath获得的是项目的名称。比如： /ssh_manager 前面有一个斜杠。 2.ssh的思想就是访问的是我们的action而不是直接的jsp，这样的话，你要学会在一个Action里面去处理很多的jsp请求。 3.模型驱动的值会默认放在值栈里面，而且，我们在一个Action里面有很多个方法的时候，每次访问一个方法的时候，就实例化一个Action,而且每个Action里面的值栈都是不一样的。 4.在jsp使用模型驱动里面的数据：1&lt;s:property value=&quot;model.属性&quot;&gt; 5.对值栈的理解：值栈就是一个栈，也就是数值是从顶到底读取的，不过它会自动帮我们去匹配，输出的是第一个匹配到的数据。==如果我们把一个对象放到值栈里面==：例如PageBean;123456789101112131415161718192021222324252627282930313233343536public class PageBean &lt;T&gt;&#123;//分页显示这个·相当于List&lt;E&gt; private int currPage;//当前页 private int pageSize;//每页显示 private int totalPage;//总页数 private int rowPage;//总记录 private List&lt;T&gt;list;//当前页面的数据 public int getCurrPage() &#123; return currPage; &#125; public void setCurrPage(int currPage) &#123; this.currPage = currPage; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public int getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public int getRowPage() &#123; return rowPage; &#125; public void setRowPage(int rowPage) &#123; this.rowPage = rowPage; &#125; public List&lt;T&gt; getList() &#123; return list; &#125; public void setList(List&lt;T&gt; list) &#123;//这个是从数据库得到的，上面的其他数据是提供给数据库的。 this.list = list; &#125; 之后在页面我们就可以使用一整个pageBean,包括里面的各个属性，而且可以直接使用属性的名字来获得该属性的值，它会在底层自动帮我们查找。而且还支持对list属性的iterator迭代。他会自动的将pageBean里面的list属性直接的给到我们的 注意：这个value要写对，要和pageBean里面的属性值一样。 2.对于页面单纯跳转到显示页面的做法：首先，对任何的jsp页面的请求，我们都是将请求给到我们的action进行处理的，这个的好处就是防止直接访问到我们的jsp，还有一个醉最大的好处就是，我们跳转到的页面需要的数据可以先在我们的Action里面直接准备好，这样jsp页面对java代码的耦合性就达到最低了。例如在员工系统里面，我们需要修改一个员工的信息，这时候我们的修改页面需要的数据有，该员工的所有原来的信息，这就要将该对象放到模型驱动里面，或者是值栈里面，接着，如果修改页面还需要所有部门以供选择的话，还要将所有部门的集合放到值栈里，这样在页面进行跳转后，我们的jsp页面就可以很直接的就得到我们在action里面为准备的所有的数据。直接利用==ognl==表达式就可以得到。 3.对于jsp页面请求的时候数据接收时发生错误会报出很多错误，其中就有一个是无法找到action,其实不是找不到，是它在为Action进行数据的封装的时候出现了错误而无法直接实例化我们得Action.特别是在使用了list集合的jsp页面，好像数据填写不完全就会报错，这个我也不是很懂。我的想法就是这个可以直接交给到我们的脚本进行判断，如果填写不符合规则就提交不了。很简单，不要后台进行处理。你还可以直接利用我们的ajax技术进行及时的提醒等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于使用hexo搭建自己的博客]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo%2F</url>
      <content type="text"><![CDATA[环境的搭建 1.介绍：我们使用的这个博客生成器，其实是一个台湾大学生创建的，它的环境是主流的node.js,因此，我们需要先配置好node.js环境，node.js的安装自己百度就可以很快搞定，它有windows,linux，mac都有。使用这个hexo我们可以很简单的创建一个很炫酷的个人博客哦。 2.安装好node.js后，我们需要安装hexo,安装的指令是，在我们的命令窗口，输入： npm install hexo -g这个表示在这个环境里面安装好博客生成器。之后我们就可以使用简单的命令生成自己的博客了。 3.首先，在一个文件夹里面，按住shift 后右键，选择在此打开cmd,输入：hexo init,这样就生成了一个简单的博客需要的所有配置文件，再使用hexo g这样就生成了一个博客，使用hexo s启动博客，在自己打的浏览器输入cmd里面的地址可以看到一个 HEXO 的博客页面。 修改自己的博客 1.搭建好自己的博客后，需要修改很多的内容来进行自己的优化，主要是修改两个配置文件，一个是站目录下面的配置文件，另外一个是主题目录下的配置文件。这两个文件的配置可以使得你的hexo主题改变很大。 2.站目录下的配置文件主要是配置我们项目发布到github的参数，在这个配置文件的最下面配置，注意我们使用的hexo版本，我使用的是3.0好像，这个版本在上传文件的时候，下面的代码： deploy: type: git repository: https://github.com/kingfou/kingfou.github.io.git branch: master 2.配置好后，将文件上传到我们的github上面，首先你要自己先在github上面注册和申请好自己的仓库，很简单的。自己百度。之后的操作就是：hexo d如果报错，请用github的 shell命令器cmd到自己的博客站目录下面 hexo d。如果提醒没有初始化什么的，直接git init,之后就可以了。 3.关于自己对主题的一些修改，这些都得在主题的那个配置文件里面自己一个一个慢慢设置，我使用的是next这款主题，十分炫酷。直接上next的官网就可以看到怎么修改一些内容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh总结1]]></title>
      <url>%2F2017%2F03%2F10%2Fssh%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[1.理解：我们在项目里，本来是有三个配置文件要写的， 1.struts.xml：负责对action和访问的Action进行匹配，并且会根据Action的返回结果进行页面的跳转操作，在struts.xml里面，要注意的就是跳转的形式，result type的取值又很多，比如我们的json形式就是加入json插件又的一种同时，在struts.xml里面，我们还要注意的是action对Action里面方法的访问的写法；struts里面也定义了很多的拦截器，如果我们使用了自定义的拦截器的话，那么在访问该Action的时候，我们需要手动的去调用默认的拦截器栈。还有就是我们的常量的配置，可以起到很多的作用，比如自定义的错误消息的提醒，启用一些其他属性。这个可以查我们的default-struts这个配置文件，里面又所有的常量。 2.applicationContext.xml：1.这个配置文件是我们spring里面的配置文件，它的作用就是进行bean的注入，EJB,企业级java bean ，也就是说，将对bean的实例化等操作直接在配置文件里面完成。在ssh里面，我们也是直接的使用这个bean.xml来对我们的struts.xml和beans.xml进行整合的；1.对struts进行整合，就是将Action类的实例化的工作直接交给到我们的beans.xml，这时候在配置我们的action的时候，class=”id”,这个id就是我们在beans..xml里面的id,2.对hibernate进行整合：我们会将hibernate配置文件的内容直接都在这个beans.xml里面进行配置，这时候，我们的Dao类需要继承一个类，HibernateDaoSupport类，这个类继承后需要我们在beans.xml里面进行一些属性的配置，毕竟是继承来的，有很多的属性是需要配置的。 1.配置数据源，数据源可以写在一个新的peoperties文件里，我们在beans.xml里面直接读取赋值就可以，beans.xml读取其他的配置文件时候，要加入一个常量的配置： &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; 这句话表示我们会加载src目录下面的配置文件，之后对数据源进行配置，内容如下： ` 注意这个bean的包所在；就是我们引进来c3p0的jar包； 2.配置sessionFactory会话工厂：也就是对数据库的最高级操作，这个是一个重量级的 对象，一般我们只会实例化一次， 之后，它就接管数据库的链接管理， 使用数据库的时候，直接调用它提供的openSession()就可以得到一次岁数据库的操作。。 注意这个bean里需要配置以下三个属性值： 1.dataSource: 2.hibernateProperties:这个文件主要配饰hibernate对于的数据库类型和sql语句的一些显示，表的自动创建等： 由于这些属性是本来就存在的，因此我们属于的是properties文件的属性的注入形式： &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;/props&gt; 3.mappingResources:这个配置的是我们的domain类的关系映射文件，由于关系映射文件有多个， 因此需要用&lt;list&gt;标签列出来： &lt;list&gt; &lt;value&gt;com/imooc/domain/Product.hbm.xml&lt;/value&gt; ..... &lt;/list&gt; 12 接下来我们讲一下，为什么在继承了HibernateDaoSupport这个类的时候，我们就要去配置这个sesionFactory这个类：首先查看我们的HibernateDaoSupport的源码，我们知道，在这个源码里，它提供了一个HibernateTemplate对象，这个就是我们在dao进行hibernate操作的根本。但是这个对象的实例化，也就是创建,需要传入一个sessionFactory,它里面有这个sessionFactory的setter方法了，我们可以在beans.xml里面直接注入就行。整个流程：1.使用HibernateDaoSupport需要配置一个bean-sessionFactory,这个bean在hibernate核心包里面，这个类里面我们要配置三个属性：数据源，hibernateProperties,mappingResource这三个属性，其中，由于hibetrnateProperties的属性是存在的，采用的是props标签，而mappingResource里的关系映射文件是用list标签来写的。 3.hibernate.cfg.xml：这个文件虽然被beans.xml整合了，但是独立的话，它的作用就是配置数据源，配置数据库的类型，配置数据库sql语言，管理关系映射文件。之后在类里通过加载这个配置文就可以得到一个sessionFactory了。12 总结：总的来说，我们最好的整合方法就是将所有的类的实例化，属性的注入等工作交给beans.xml文件，这时候，我们的hibernate的配置等全部是在这个文件立面完成的，也就是说没有了hibernate.cfg.xml文件，而action的关系映射就直接在struts.xml立面完成。使用struts和spring之前，在web.xml立面，也有很重要的配置需要记住，那就是：1.struts核心过滤器的配置： &lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2.spring 监听器的配置： &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 说说这个ContextLoaderListener的作用：它的作用就是在web启动的时候 自动的去加载我们的beans.xml配置文件，不过在默认的情况下下， 他会去加载WEB-INFO下面的applicationContext.xml这个配置文件 ，因此，如果我们的配置文件在src目录下的话，我们就需要制定加载配置文件的所在路径，需要使用到下面的标签： &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; ```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Action三种获取表单的模式]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%20Action%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[1.我们写的Action当继承了ActionSupport的时候，它会自动获取提交到该action的请求里面的表单数据，会缓存起来，如何获取呢？它的底层已经利用架构或者其他的配置文件，doj4等技术，只要我们的Action类里的属性名和表单的name标签的名字一样的时候，同时在Action里的属性有setter和getter的时候会自动获取，这个和我们的Spring的依赖注入很类似。2.通过一个implements ModelDriven接口来实例化封装的表单的数据。 3.详细解释： 域驱动：就是将表单的属性名称在action里面按照依赖注入的形式填充完成，这时候的成功因素就是Action里面的属性要和表单的name属性一致 属性驱动，所谓的属性驱动就是先将表单的提交信息封装好，成一个pojo，我们在action里的属性现在就是pojo,设置好pojo的setter和getter就行，在jsp页面写的就是pojo实例的属性。例如： `private User user;setter;getter; form;//表单形式name=”user.name”;name=”user.password” POJO://POJO类 User{ name; password; }` 表单的user会自动去寻找Action对应的属性user的，就是表单逆向寻找Action的属性。 3.模型驱动，modelDriven接口的实现，我们一开始就实现接口:`implements ModelDriven{private User user; Uer getModel(){//覆写方法if(user==null){ user=new User(); } }}`//这样就是自动的驱动我们的模型完成数据填充。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh之搭建环境]]></title>
      <url>%2F2017%2F03%2F02%2Fssh%E4%B9%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[配置文件的理解 1.struts.xml：负责对action和访问的Action进行匹配，并且会根据Action的返回结果进行页面的跳转操作，在struts.xml里面，要注意的就是跳转的形式，result type的取值又很多，比如我们的json形式就是加入json插件又的一种同时，在struts.xml里面，我们还要注意的是action对Action里面方法的访问的写法；struts里面也定义了很多的拦截器，如果我们使用了自定义的拦截器的话，那么在访问该Action的时候，我们需要手动的去调用默认的拦截器栈。还有就是我们的常量的配置，可以起到很多的作用，比如自定义的错误消息的提醒，启用一些其他属性。这个可以查我们的default-struts这个配置文件，里面又所有的常量。 2.applicationContext.xml：1.这个配置文件是我们spring里面的配置文件，它的作用就是进行bean的注入，EJB,企业级java bean ，也就是说，将对bean的实例化等操作直接在配置文件里面完成。在ssh里面，我们也是直接的使用这个bean.xml来对我们的struts.xml和beans.xml进行整合的；1.对struts进行整合，就是将Action类的实例化的工作直接交给到我们的beans.xml，这时候在配置我们的action的时候，class=”id”,这个id就是我们在beans..xml里面的id,2.对hibernate进行整合：我们会将hibernate配置文件的内容直接都在这个beans.xml里面进行配置，这时候，我们的Dao类需要继承一个类，HibernateDaoSupport类，这个类继承后需要我们在beans.xml里面进行一些属性的配置，毕竟是继承来的，有很多的属性是需要配置的。 1.配置数据源，数据源可以写在一个新的peoperties文件里，我们在beans.xml里面直接读取赋值就可以，beans.xml读取其他的配置文件时候，要加入一个常量的配置： &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;这句话表示我们会加载src目录下面的配置文件，之后对数据源进行配置，内容如下：&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; ` &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; `]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2文件上传]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[1.文件上传是在表单中完成的。表单提交到一个action里面，在action里面，我们开始对提交的文件进行操作。2.两个重要的属性的setter和getter，我们在html页面写的file 标签的名字要和Action里的名字是对应的。比如 123&lt;form method=&quot;post&quot; action=&quot;url&quot; enctype=&quot;multipart/form-data&quot;&lt;input type=&quot;file&quot; name=&quot;newname&quot;/&gt;&lt;/form&gt; 这样的话，我们可以得到上传文件的类型和名称，其中属性： 12- 1.newnameFileName(html的名字+FileName) - 2.newnameContentType(html的名字+ContentType) 这样就可以直接获取上传文件的名称和类型。 2.Action代码：1234 private File photo;private String photoFileName;private String photoContentType; html代码：1234&lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 文件上传：&lt;input type=&quot;file&quot; name=&quot;photo&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt;&lt;/form&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义错误消息]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A02%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E6%B6%88%E6%81%AF%EF%BC%89%2F</url>
      <content type="text"><![CDATA[1.ServletActionContext.getServletContext().getRealPath(“/“)可以直接获得当前项目的真实路径。 一个result代表了一个可能的输出。当Action类的方法执行完成时，它返回一个字符串类型的结果码，框架根据这个结果码选择对应的result，向用户输出。在com.opensymphony.xwork2.Action接口中定义了一组标准的结果代码，可供开发人员使用，当然了只有我们的action继承ActionSupport 这个类才可以使用下面的结果代码，如下所示： 12345678public interface Action&#123; public static final String SUCCESS = “success”; public static final String NONE = “none”; public static final String ERROR = “error”; public static final String INPUT = “input”; public static final String LOGIN = “login”;&#125; 其中 Struts2应用在运行过程中若发现addFieldError()中有信息或者类型转换失败或着输入校验失败等情况那么它会自动跳转到name为input的1&lt;result/&gt; ，然后转到INPUT所对应的页面若JSP页面中表单是用普通编写的，发生错误而返回该页面时，则原数据将消失若JSP页面中表单是用编写的，发生错误而返回该页面时，则原数据仍存在若没有提供name值为input的，那么发生错误时，将直接在浏览器中提示404错误 除了这些预定义的结果码外，开发人员也可以定义其它的结果码来满足自身应用程序的需要。 3.由上面的笔记我们可以知道，默认的返回字符串是success,input,error,none,login这些。。。 3.修改默认的消息返回配置： 4.在我们的struts的核心包下面有一个配置文件default-properties,这个配置文件是无法直接修改的，但是里面是我们可以配置的所有的常量的集合，我们在struts,xml文件里面配置的常量其实在这里是全部可以直接找到的。在这下面还有很多的配置文件，比如struts-message这个配置文件，里面就有当信息出错是加载的常量属性。struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} “{1}” “{2}” {3} 这一段是在类型不允许的时候显示的，其中，0,1,2,3是文件的详细情况。文件名和文件类型什么的。我们写了一个配置文件赋值给一个常量，1&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;msg&quot;&gt;&lt;/constant&gt; 这个配置文件完成的时候，他会把struts-message里面的1struts.messages.error.content.type.not.allowed=Content-Type not allowed: &#123;0&#125; &quot;&#123;1&#125;&quot; &quot;&#123;2&#125;&quot; &#123;3&#125; 直接换成msg.properties下面的代码1struts.messages.error.content.type.not.allowed=\u60A8\u4E0A\u4F20\u7684\u6587\u4EF6\&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;\u7C7B\u578B\u6709\u8BEF 这一切，其实就是将一个常量直接等于一个配置文件，配置文件自己再为常量赋值？？？？ 5.每次使用自己写的拦截器的时候，一定要自己再手动加默认的拦截器栈。 6.文件上传的时候，对文件的格式，文件的大小一起其他的限制，我们可以直接在fileUpload这个拦截器里面直接配置好就行，必要的时候，可以自己配置文件不符合限制的时候的提示消息，这个消息的常量在我们的struts-messgae里面找到对应的属性，将此属性直接在自己写的配置文件里赋给新的提示消息值，之后将此配置文件赋值给对应的常量。 具体流程： 121.找到struts-message文件里面对应的属性，例如文件类型错误：struts.messages.error.content.type.not.allowed 122.将此属性copy到自己的配置文件里重新赋值：struts.messages.error.content.type.not.allowed=？？？？？ 12343.在我们的struts.xml配置文件里配置常量：&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;msg&quot;&gt;&lt;/constant&gt;这个msg就是我们自己的消息提示配置文件，我们将这个配置文件赋值给到这个常量就行。 14.这样当文件不符合的时候就会提示我们自定义的消息了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[strut2拦截器]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%20%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
      <content type="text"><![CDATA[1.拦截器和过滤器本质上是一一样的。只是拦截器是一个一个按照顺序执行的，而过滤器则是按照配匹配的方式执行的。 2.struts2的架构实现就是依赖大量的拦截器来实现的。例如prepare ，fileupload,什么的，它会自动的将表单的数据直接封装成我们的Action类，我们就可以直接在Action里面使用了，这底层的机制就是依赖注入。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2实现ajax]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E5%AE%9E%E7%8E%B0Ajax%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[1.Ajax是什么，怎么实现？ 使用JQuery的方法实现 使用html的方法实现 JSON:在JQuery里面，我们提供了两种实现的方法 load(URL,data,callback);其url是请求的url，也就是要访问的服务的地址，data是请求的参数，可以为空，也可以带请求参数，最后的是一个回调函数，请求的数据直接放在回调函数里面。回调函数的构造类型如下：1234可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：responseTxt - 包含调用成功时的结果内容statusTXT - 包含调用的状态xhr - 包含 XMLHttpRequest 对象 2.$.get(URL,callback); 这是使用jquery的方法写的ajax,回调函数的使用如下： 12function(data,status)第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。 $.post(URL,data,callback);这个的用法和get是一样的，只是它可以带有自己的请求参数，也就是将页面的某个属性直接赋值后请求，例如直接请求id是多少的某个属性。 2.使用我们的struts实现ajax的时候，要手动导入另外的两个包。一个是struts提供的JSON插件支持包，另外一个就是JSON的包，它提供将对象直接字符串化的方法，这样才可以直接在action里面放回字符串的请求结果。此外，我们的struts配置内容如下：1234567&lt;package name=&quot;root1&quot; namespace=&quot;/&quot; extends=&quot;json-default&quot; &gt;&lt;!-- 实现AJAX的Action配置 --&gt; &lt;action name=&quot;ajax&quot; class=&quot;com.imook.action.AjaxAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;json&quot;&gt;&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 这里的json-default包其实就是我们的struts-josn的插件。这个是请求的数据是对象的时候； 3.请求的是集合的时候。其实原理是一样的，就是请求后在html页面得到的那个数据其实四一个集合的字符串，我们可以先得到该对象，之后进行遍历就可以得到我们想过的数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文件上传的限制]]></title>
      <url>%2F2017%2F03%2F02%2Fstruts2%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[1.限制上传的文件大小可以直接在我们的fileUpload拦截器里直接配置好属性就可以fileUpload的属性如下：12345&lt;interceptor-ref=&quot;fileUpload&quot;&gt; &lt;param name=&quot;maximumSize&quot;&gt; 1024*1024; &lt;/param&gt;&lt;/interceptor&gt; 2.由于文件上传的时候，自己也会有一个默认的最大值，那个就是2M，这个时候，我们还是要修改一个常量，那就是struts.multipart.maxSize1&lt;constant name=&quot;struts.multipart.maxSize&quot; value=&quot;5242880&quot;&gt;&lt;/constant&gt; 3.文件下载：12345678910contentType内容类型，和互联网MIME标准中的规定类型一致，例如text/plain代表纯文本，text/xml表示XML，image/gif代表GIF图片，image/jpeg代表JPG图片inputName下载文件的来源流，对应着action类中某个类型为Inputstream的属性名，例如取值为inputStream的属性需要编写getInputStream()方法contentDisposition文件下载的处理方式，包括内联(inline)和附件(attachment)两种方式，而附件方式会弹出文件保存对话框，否则浏览器会尝试直接显示文件。取值为：attachment;filename=&quot;struts2.txt&quot;，表示文件下载的时候保存的名字应为struts2.txt。如果直接写filename=&quot;struts2.txt&quot;，那么默认情况是代表inline，浏览器会尝试自动打开它，等价于这样的写法：inline; filename=&quot;struts2.txt&quot;bufferSize下载缓冲区的大小。在这里面，contentType属性和contentDisposition分别对应着HTTP响应中的头Content-Type和Content-disposition头。 4.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HQL语句]]></title>
      <url>%2F2017%2F02%2F22%2FHQL%20%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[1.复习hibernate 的配置文件的写法： 2.回忆配置文件的配置顺序： 数据库部分：在这一部分，我们的配置顺序就是按照前面的图进行配置，主要的参数有1234567891011121314151617181920&lt;!--配置数据库--&gt;connection.driver_classconnection.urlconnection=usernameconnection=userpassword&lt;!-- 配置使用的是什么数据库 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 配置sql语句的一些属性 --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 读取配置好的表格的属性 --&gt; &lt;mapping resource=&quot;com/imooc/domain/User.hbm.xml&quot;/&gt; &lt;mapping resource=&quot;com/imooc/domain/Goods.hbm.xml&quot;/&gt; &lt;mapping resource=&quot;com/imooc/domain/Paper.hbm.xml&quot;/&gt; &lt;!--在上面的sql语句配置中，show_sql表示输出实现时候的sql语句，hbm2ddl.auto则表示的是自动按照映射文件生成表格。--&gt; 3.加载配置文件：配置文件默认是在src目录下面的，如果不在根目录下面，则加载的时候要写全路径，也就是在src下面的==全路径==。 4.关系映射文件里面的one-to-many 和many-to-one: 首先确定好是一对多还是多对一，多的那个需要有外键，外键的参数就是那个一的主键。也就是==多==的这个里面的外键其实是==一==那个的主键。这时候，在创建表格的时候，我们这样考虑，其实多这个表的创建是需要一这个表的主键作为外键的。因此，我们需要注意顺序，就是先写的资源是==一==的那个，之后再写多的那个。这就可以解释我们在配置==一==那个表的关系映射文件的时候，为什么在配置set的时候有那么多的参数要配置，为的就是可顺利创建==多==的那个表格。 123456&lt;set name=&quot;domain里面的属性名称&quot;&gt;&lt;key column=&quot;user_id&quot;&gt;&lt;!--作为别人的外键--&gt;&lt;one-many class=&quot;对应的类&quot;/&gt;&lt;/set&gt;其实一个类对应一个表格，因此它可以寻找到该表格的。可以这样想：其实是按照你给到的类，对应到表格，在对应到表格的具体栏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts2拦截器]]></title>
      <url>%2F2017%2F02%2F20%2Fstruts2%20%E5%81%9A%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%2F</url>
      <content type="text"><![CDATA[1.由于struts2的拦截器只对我们的action请求起到拦截作用，因此，我们完全可以直接访问jsp页面而不被拦截，但是如果我们的jsp是放在WEB-INF下面的话，我们则可以解决此问题2.拦截器拦截的原理是，判断session里是否已经有了登录信息，有则放行，invocation.invocate();这个方法表示比可以继续访问我们的action了，这个action是在struts里的配置，它是先找到struts.xml配置，再找到对象的Action的，当然，Action也可能不存在，直接做页面的跳转工作就行。3.拦截器的使用注意：使用自定义的拦截器的时候，默认的拦截器是关闭的。这是在访问这个action的时候发生的，也就是当你在访问此action的时候，如果你使用了自定义拦截器的话，那么在智执行这个action访问的时候只会调用你定义的拦截器，默认的拦截器是关闭的，除非你在此之前显式调用。4.由于默认拦截器比较多，一般我们自己应以一个拦截器栈，将默认拦截器栈先放进去，再放我们的自定义拦截器就形成我们自己的拦截器栈。 5.详细说明见链接]]></content>
    </entry>

    
  
  
</search>
